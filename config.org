:HIDDEN:
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+PROPERTY: header-args :results silent :tangle config.el
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD_EXTRA: <style>div#content { max-width: 2000px; }</style>
#+SEQ_TODO: TODO NEXT ACTIVE | DISABLED
:END:
#+TITLE: Emacs Configuration

* Core
** Package
 #+BEGIN_SRC emacs-lisp
 ;; `(online?)` is a function that tries to detect whether you are online.
 ;; We want to refresh our package list on Emacs start if we are.
 (require 'cl)
 (defun online? ()
   (if (and (functionp 'network-interface-list)
            (network-interface-list))
       (some (lambda (iface) (unless (equal "lo" (car iface))
                          (member 'up (first (last (network-interface-info
                                                    (car iface)))))))
             (network-interface-list))
     t))

 ;; Emacs comes with a package manager for installing more features.
 ;; The default package repository doesn't contain much, so we tell it
 ;; to use MELPA as well.
 (setq package-user-dir (concat dotfiles-dir "elpa"))
 (require 'package)
 (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
 (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

 ;; To get the package manager going, we invoke its initialise function.
 (package-initialize)

 ;; If we're online, we attempt to fetch the package directories if
 ;; we don't have a local copy already. This lets us start installing
 ;; packages right away from a clean install.
 (when (online?)
   (unless package-archive-contents (package-refresh-contents)))

 ;; `Paradox' is an enhanced interface for package management, which also
 ;; provides some helpful utility functions we're going to be using
 ;; extensively. Thus, the first thing we do is install it if it's not there
 ;; already.
 (when (not (package-installed-p 'paradox))
   (package-install 'paradox))

 ;; We're going to be using `use-package' to manage our dependencies.
 ;; In its simplest form, we can call eg. `(use-package lolcode-mode)'
 ;; to install the `lolcode-mode' package. We'd also declare one or more
 ;; entry points so the module isn't loaded unneccesarily at startup.
 ;; For instance, `(use-package my-module :commands (my-function))' will
 ;; defer loading `my-module' until you actually call `(my-function)'.
 ;;
 ;; Read about it in detail at https://github.com/jwiegley/use-package

 ;; First, we make sure it's installed, using a function provided by
 ;; Paradox, which we've just installed the hard way.
 (paradox-require 'use-package)

 ;; Next, we load it so it's always available.
 (require 'use-package)

 ;; Finally, we enable `use-package-always-ensure' which makes
 ;; use-package install every declared package automatically from ELPA,
 ;; instead of expecting you to do it manually.
(setq use-package-always-ensure t)


   #+END_SRC
** Libraries
*** config
 #+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'cl-lib))

 (defun core/font-lock-replace-symbol (mode reg sym)
   "Given a major mode `mode', replace the regular expression `reg' with
 the symbol `sym' when rendering."
   (font-lock-add-keywords
    mode `((,reg
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      ,sym 'decompose-region)))))))
 (defun core/exec (command)
   "Run a shell command and return its output as a string, whitespace trimmed."
   (s-trim (shell-command-to-string command)))

 (defun core/exec-with-rc (command &rest args)
   "Run a shell command and return a list containing two values: its return
 code and its whitespace trimmed output."
   (with-temp-buffer
     (list (apply 'call-process command nil (current-buffer) nil args)
           (s-trim (buffer-string)))))

 (defun core/is-exec (command)
   "Returns true if `command' is an executable on the system search path."
   (f-executable? (s-trim (shell-command-to-string (s-concat "which " command)))))

 (defun core/resolve-exec (command)
   "If `command' is an executable on the system search path, return its absolute path.
 Otherwise, return nil."
   (-let [path (s-trim (shell-command-to-string (s-concat "which " command)))]
     (when (f-executable? path) path)))

 (defun core/exec-if-exec (command args)
   "If `command' satisfies `core/is-exec', run it with `args' and return its
 output as per `core/exec'. Otherwise, return nil."
   (when (core/is-exec command) (core/exec (s-concat command " " args))))



 (defun core/getent (user)
   "Get the /etc/passwd entry for the user `user' as a list of strings,
 or nil if there is no such user. Empty fields will be represented as nil,
 as opposed to empty strings."
   (-let [ent (core/exec (s-concat "getent passwd " user))]
     (when (not (s-blank? ent))
       (-map (lambda (i) (if (s-blank? i) nil i))
             (s-split ":" ent)))))

 (defun core/user-full-name ()
   "Guess the user's full name. Returns nil if no likely name could be found."
   (or (core/exec-if-exec "git" "config --get user.name")
       (elt (core/getent (getenv "USER")) 4)))

 (defun core/user-email ()
   "Guess the user's email address. Returns nil if none could be found."
   (or (core/exec-if-exec "git" "config --get user.email")
       (getenv "EMAIL")))

(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))


  (eval-and-compile

    (defun my/resolve-hook-forms (hooks)
      (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
               for hook in (doom-enlist (doom-unquote hooks))
               if (eq (car-safe hook) 'quote)
                collect (cadr hook)
               else if quoted-p
                collect hook
               else collect (intern (format "%s-hook" (symbol-name hook)))))

    (defvar my/transient-counter 0)
    (defmacro add-transient-hook! (hook &rest forms)
      "Attaches transient forms to a HOOK.

    HOOK can be a quoted hook or a sharp-quoted function (which will be advised).

    These forms will be evaluated once when that function/hook is first invoked,
    then it detaches itself."
      (declare (indent 1))
      (let ((append (eq (car forms) :after))
            (fn (intern (format "my/transient-hook-%s" (cl-incf my/transient-counter)))))
        `(when ,hook
           (fset ',fn
                 (lambda (&rest _)
                   ,@forms
                   (cond ((functionp ,hook) (advice-remove ,hook #',fn))
                         ((symbolp ,hook)   (remove-hook ,hook #',fn)))
                   (unintern ',fn nil)))
           (cond ((functionp ,hook)
                  (advice-add ,hook ,(if append :after :before) #',fn))
                 ((symbolp ,hook)
                  (add-hook ,hook #',fn ,append)))))))

  (defmacro add-hook! (&rest args)
    "A convenience macro for `add-hook'. Takes, in order:

    1. Optional properties :local and/or :append, which will make the hook
       buffer-local or append to the list of hooks (respectively),
    2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
       a quoted hook variable or a quoted list of hook variables. If unquoted, the
       hooks will be resolved by appending -hook to each symbol.
    3. A function, list of functions, or body forms to be wrapped in a lambda.

  Examples:
      (add-hook! 'some-mode-hook 'enable-something)
      (add-hook! some-mode '(enable-something and-another))
      (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
      (add-hook! (one-mode second-mode) 'enable-something)
      (add-hook! :append (one-mode second-mode) 'enable-something)
      (add-hook! :local (one-mode second-mode) 'enable-something)
      (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
      (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

  Body forms can access the hook's arguments through the let-bound variable
  `args'."
    (declare (indent defun) (debug t))
    (let ((hook-fn 'add-hook)
          append-p local-p)
      (while (keywordp (car args))
        (pcase (pop args)
          (:append (setq append-p t))
          (:local  (setq local-p t))
          (:remove (setq hook-fn 'remove-hook))))
      (let ((hooks (my/resolve-hook-forms (pop args)))
            (funcs
             (let ((val (car args)))
               (if (memq (car-safe val) '(quote function))
                   (if (cdr-safe (cadr val))
                       (cadr val)
                     (list (cadr val)))
                 (list args))))
            forms)
        (dolist (fn funcs)
          (setq fn (if (symbolp fn)
                       `(function ,fn)
                     `(lambda (&rest _) ,@args)))
          (dolist (hook hooks)
            (push (cond ((eq hook-fn 'remove-hook)
                         `(remove-hook ',hook ,fn ,local-p))
                        (t
                         `(add-hook ',hook ,fn ,append-p ,local-p)))
                  forms)))
        `(progn ,@(nreverse forms)))))

  (defmacro remove-hook! (&rest args)
    "Convenience macro for `remove-hook'. Takes the same arguments as
  `add-hook!'."
    `(add-hook! :remove ,@args))

 #+END_SRC
*** packages
**** async
 #+BEGIN_SRC emacs-lisp
(use-package async :demand t
    :config
    (dired-async-mode 1))
 #+END_SRC
**** subr-x
 #+BEGIN_SRC emacs-lisp
(use-package subr-x :demand t :ensure nil)

 #+END_SRC

**** dash
 #+BEGIN_SRC emacs-lisp
(use-package dash
  :ensure t
  :config
  (dash-enable-font-lock))
(use-package dash-functional
  :ensure t)
 #+END_SRC

**** f
 #+BEGIN_SRC emacs-lisp
(use-package f
  :ensure t)
 #+END_SRC

**** s
  #+BEGIN_SRC emacs-lisp
(use-package s
  :ensure t)
  #+END_SRC

**** ht
  #+BEGIN_SRC emacs-lisp
(use-package ht
  :ensure t)
  #+END_SRC

**** a
 #+begin_src emacs-lisp
(require 'let-alist)
(use-package a
  :ensure t)
 #+end_src

**** persistent-soft
 #+BEGIN_SRC emacs-lisp
(use-package persistent-soft
  :ensure t)
 #+END_SRC

**** request
 #+BEGIN_SRC emacs-lisp
(use-package request :ensure t)
 #+END_SRC
** Linux
*** config
 #+BEGIN_SRC emacs-lisp
(setq x-gtk-use-system-tooltips nil)
  #+END_SRC
*** packages
**** exec-path-from-shell
 #+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
:config
(exec-path-from-shell-initialize))
 #+END_SRC
**** counsel
  #+BEGIN_SRC emacs-lisp
  (use-package counsel
    :config
    (push (concat (getenv "HOME") "/.local/share/applications/") counsel-linux-apps-directories)
     (defun my/counsel-linux-app-format-function (name comment exec)
       "Default Linux application name formatter.
   NAME is the name of the application, COMMENT its comment and EXEC
   the command to launch it."
       (format "% -45s %s"
               (propertize name 'face 'font-lock-builtin-face)
               (or comment "")))
     (setq counsel-linux-app-format-function #'my/counsel-linux-app-format-function))


  #+END_SRC

**** gpastel
#+BEGIN_SRC emacs-lisp
(use-package gpastel)

#+END_SRC

** DISABLED macOS
*** DISABLED config
  #+BEGIN_SRC emacs-lisp
 (setq ns-function-modifier 'hyper)

 (defun user-swap-meta-and-super ()
   "Swap the mapping of Meta and Super.
 Very useful for people using their Mac with a
 Windows external keyboard from time to time."
   (interactive)
   (if (eq mac-command-modifier 'super)
       (progn
         (setq mac-command-modifier 'meta)
         (setq mac-option-modifier 'super)
         (message "Command is now bound to META and Option is bound to SUPER."))
     (setq mac-command-modifier 'super)
     (setq mac-option-modifier 'meta)
     (message "Command is now bound to SUPER and Option is bound to META.")))

 (menu-bar-mode +1)

 (when (fboundp 'set-fontset-font)
   (set-fontset-font t 'unicode "Apple Color Emoji" nil 'prepend))

(setq locate-make-command-line (lambda (s) `("mdfind" "-name" ,s)))

(setq mac-emulate-three-button-mouse t)

(setq shift-select-mode t)

(global-set-key (kbd "<s-up>")    'beginning-of-buffer)
(global-set-key (kbd "<s-down>")  'end-of-buffer)
(global-set-key (kbd "<s-left>")  'move-beginning-of-line)
(global-set-key (kbd "<s-right>") 'move-end-of-line)

(define-key global-map (kbd "s-+") 'text-scale-increase)
(define-key global-map (kbd "s--") 'text-scale-decrease)

(global-set-key (kbd "s-f") 'isearch-forward-regexp)

(global-set-key (kbd "<M-up>") 'backward-paragraph)
(global-set-key (kbd "<M-down>") 'forward-paragraph)

(global-set-key (kbd "M-<backspace>") 'backward-kill-word)

(global-set-key (kbd "C-x K") 'kill-this-buffer)

(setq delete-by-moving-to-trash t)

(setq ns-right-alternate-modifier nil)

(setq mac-option-modifier 'meta)
(setq mac-command-modifier 'super)

(global-set-key [(super a)] 'mark-whole-buffer)
(global-set-key [(super c)] 'kill-ring-save)
(global-set-key [(super g)] 'isearch-repeat-forward)
(global-set-key [(super l)] 'goto-line)
(global-set-key [(super q)] 'save-buffers-kill-terminal)
(global-set-key [(super s)] 'save-buffer)
(global-set-key [(super v)] 'yank)
(global-set-key [(super x)] 'kill-region)
(global-set-key [(super w)] (lambda ()
                              (interactive)
                              (kill-buffer (current-buffer))))
(global-set-key [(super z)] 'undo)

(setq visible-bell nil)

(setq mac-right-alternate-modifier nil)

(global-set-key (kbd "s-K") nil)
(global-set-key (kbd "s-k") nil)
(add-hook 'prog-mode-hook
          (lambda ()
            ;; compile short cuts
            (define-key (current-local-map) (kbd "s-K") 'compile)
            (define-key (current-local-map) (kbd "s-k") 'recompile)))

(defun my/open-finder-at (path)
  "Open Finder app with the given PATH."
  (let* ((finder (executable-find "open"))
         (command (format "%s %s" finder path)))
    (shell-command command)))

(defun my/open-project-in-finder ()
  "Open current project in Finder app."
  (interactive)
  (if (projectile-project-p)
      (my/open-finder-at (projectile-project-root))
    (message "There is no active project.")))

(defun my/open-current-file-in-finder ()
  "Open current file in Finder."
  (interactive)
  (let ((file (buffer-file-name)))
    (if file
        (my/open-finder-at (file-name-directory file))
      (message "Buffer has not been saved yet!"))))


 #+END_SRC

 #+results:
 | lambda | nil | (define-key (current-local-map) (kbd s-K) 'compile) | (define-key (current-local-map) (kbd s-k) 'recompile) |

*** DISABLED packages
**** DISABLED exec-path-from-shell
 #+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
:config
(exec-path-from-shell-initialize))
 #+END_SRC

**** DISABLED pbcopy
 #+BEGIN_SRC emacs-lisp
(use-package pbcopy
  :ensure t)
 #+END_SRC
**** DISABLED Set-path
   #+BEGIN_SRC emacs-lisp
 (paradox-require 'exec-path-from-shell)

 (when (memq window-system '(x mac ns))
   (exec-path-from-shell-initialize))
   #+END_SRC
* Modules
** Appearance
*** config
 #+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil
                         :family "Source Code Pro"
                         :height 100
                         :weight 'normal
                         :width 'normal
                         )
     (set-face-attribute 'Info-quoted nil
                         :slant 'Italic)
     (set-face-attribute 'font-lock-string-face nil
                         :slant 'Italic)

 (defun module-fonts/spec-to-list (spec)
   (s-split "-" spec))

 (defun module-fonts/list-to-spec (spec)
   (s-join "-" spec))

 (defun module-fonts/update-font-spec-size (spec increment)
   (module-fonts/list-to-spec
    (-update-at 7 (lambda (i) (number-to-string
                               (+ (string-to-number i) increment)))
                (module-fonts/spec-to-list spec))))

 (defun module-fonts/update-font-size (increment)
   (set-frame-font
    (module-fonts/update-font-spec-size (frame-parameter nil 'font) increment)))

 (global-set-key (kbd "C-M--") (lambda () (interactive)
                                 (module-fonts/update-font-size -1)))
 (global-set-key (kbd "C-M-=") (lambda () (interactive)
                                 (module-fonts/update-font-size 1)))

 (require 'term)

 ;; Don't defer screen updates when performing operations.
 (setq redisplay-dont-pause t)

 ;; When not in a terminal, configure a few window system specific things.
 (when window-system
   (setq frame-title-format '(buffer-file-name "%f" ("%b")))
   (tooltip-mode -1)
   (mouse-wheel-mode t)
   (blink-cursor-mode -1))

 ;; Show line numbers in buffers.
 (global-linum-mode -1)
 (setq linum-format (if (not window-system) "%4d " "%4d"))

 ;; Show column numbers in modeline.
 (setq column-number-mode t)

 ;; Show current function in modeline.
 (which-function-mode)

 ;; Ensure linum-mode is disabled in certain major modes.
 (setq linum-disabled-modes
       '(term-mode slime-repl-mode magit-status-mode help-mode nrepl-mode
                   mu4e-main-mode mu4e-headers-mode mu4e-view-mode
                   mu4e-compose-mode))
 (defun linum-on ()
   (unless (or (minibufferp) (member major-mode linum-disabled-modes))
     (linum-mode 1)))

 ;; Highlight matching braces.
 (show-paren-mode 1)

 ;; Handle ANSI colours in compile buffer output.
 ;; From https://gist.github.com/jwiegley/8ae7145ba5ce64250a05
 (defun compilation-ansi-color-process-output ()
   (ansi-color-process-output nil)
   (set (make-local-variable 'comint-last-output-start)
        (point-marker)))
 (add-hook 'compilation-filter-hook #'compilation-ansi-color-process-output)

 (setq-default
   bidi-display-reordering nil         ; disable bidirectional text for tiny performance boost
   blink-matching-paren nil            ; don't blink--too distracting
   cursor-in-non-selected-windows nil  ; hide cursors in other windows
   display-line-numbers-width 3        ; minimum width used to display line numbers
   frame-inhibit-implied-resize t      ; prevent frames from automatically resizing themselves
   highlight-nonselected-windows nil   ; don't highlight selections in other windows
   fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist) fringe-indicator-alist)
   indicate-buffer-boundaries nil      ; don't indicate beginning and end of buffer in fringe
   indicate-empty-lines nil            ; don't indicate empty lines in fringe
   max-mini-window-height 0.3          ; maximum height for resizing mini windows
   mode-line-default-help-echo nil     ; disable mode-line mouseovers
   mouse-yank-at-point t               ; middle-click paste at point, not at click
   resize-mini-windows 'grow-only      ; Minibuffer resizing
   show-help-function nil              ; hide :help-echo text
   split-width-threshold 160           ; favor horizontal splits
   use-dialog-box nil                  ; always avoid GUI
   visible-cursor nil                  ; don't make cursor 'very visible'
   x-stretch-cursor nil                ; don't add wide glyph under cursor
   sentence-end-double-space nil
   mark-ring-max 64
   global-mark-ring-max 128
   save-interprogram-paste-before-kill t
   create-lockfiles nil
   echo-keystrokes 0.01
   global-hl-line-mode t


   jit-lock-defer-time nil             ; defer jit font locking slightly to [try to] improve Emacs performance
   jit-lock-stealth-nice 0.5           ; pause time between fontify chunks
   jit-lock-stealth-time 1             ; time to wait before start of stealth fontify
   jit-lock-stealth-verbose nil        ; silence stealth fontification
   ;; `pos-tip' defaults
   pos-tip-internal-border-width 6     ; increase pos-tip width
   pos-tip-border-width 1              ; define border width
   ;; no beeping or blinking please
   ring-bell-function #'ignore         ; don't beep
   visible-bell nil)                   ; don't blink

    #+END_SRC
*** better-defaults
#+BEGIN_SRC emacs-lisp
(use-package better-defaults)

(setq mouse-autoselect-window t
      focus-follows-mouse t)
#+END_SRC
*** doom
**** doom-themes
 #+BEGIN_SRC emacs-lisp
  (use-package doom-themes

    :config
    :init
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    ;; Enable custom neotree theme (all-the-icons must be installed!)
    (doom-themes-neotree-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))

  (load-theme 'doom-one)

 #+END_SRC
**** doom-modeline
 #+BEGIN_SRC emacs-lisp
(use-package doom-modeline

:init
(doom-modeline-mode +1))
 #+END_SRC
*** all-the-icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons )
#+END_SRC
**** all-the-icons-ivy
 #+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :ensure t
  :config
 (all-the-icons-ivy-setup)
 (defun my/*disable-all-the-icons-in-tty (orig-fn &rest args)
     (when (display-graphic-p)
       (apply orig-fn args)))

(setq all-the-icons-ivy-file-commands
      '(counsel-find-file counsel-file-jump counsel-recentf counsel-projectile-find-file counsel-projectile-find-dir))

   ;; all-the-icons doesn't work in the terminal, so we "disable" it.
   (dolist (fn '(all-the-icons-octicon all-the-icons-material
                  all-the-icons-faicon all-the-icons-fileicon
                  all-the-icons-wicon all-the-icons-alltheicon))
      (advice-add fn :around #'my/*disable-all-the-icons-in-tty)))
 #+END_SRC
*** hlinum
#+BEGIN_SRC emacs-lisp
 ;; Highlight the line number of the current line.
 (use-package hlinum
   :config
   (hlinum-activate))
#+END_SRC
*** diminish
#+BEGIN_SRC emacs-lisp
 ;; Unclutter the modeline
 (use-package diminish )

 (eval-after-load "eldoc" '(diminish 'eldoc-mode))
 (eval-after-load "autopair" '(diminish 'autopair-mode))
 (eval-after-load "abbrev" '(diminish 'abbrev-mode))
 (eval-after-load "js2-highlight-vars" '(diminish 'js2-highlight-vars-mode))
 (eval-after-load "mmm-mode" '(diminish 'mmm-mode))
 (eval-after-load "skewer-html" '(diminish 'skewer-html-mode))
 (eval-after-load "skewer-mode" '(diminish 'skewer-mode))
 (eval-after-load "auto-indent-mode" '(diminish 'auto-indent-minor-mode))
 (eval-after-load "cider" '(diminish 'cider-mode))
 (eval-after-load "smartparens" '(diminish 'smartparens-mode))

#+END_SRC
** General
*** config
 #+BEGIN_SRC emacs-lisp
 (setq savehist-file (concat dotfiles-cache-dir "savehist")
       history-length 500
       savehist-save-minibuffer-history t
       savehist-autosave-interval nil ; save on kill only
       savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
       save-place-file (concat dotfiles-cache-dir "saveplace"))

(setq-default save-place t)



(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))

(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))

  (setq undo-limit (* 1024 10 10)
        undo-outer-limit (* 1024 10 10)
        undo-strong-limit (* 1024 10 10))


 (setq-default
  bookmark-default-file         (concat dotfiles-cache-dir "bookmarks")
  abbrev-file-name             (concat dotfiles-local-dir "abbrev.el")
  auto-save-list-file-name     (concat dotfiles-cache-dir "autosave")
  pcache-directory             (concat dotfiles-cache-dir "pcache"))

;; move auto-save to the cache
(let ((dir (expand-file-name (concat dotfiles-cache-dir "auto-save/"))))
  (setq auto-save-list-file-prefix (concat dir "saves-"))
  (setq auto-save-file-name-transforms `((".*" ,(concat dir "save-") t))))

(setq help-window-select t)

(setq-default
 ad-redefinition-action 'accept          ; silence advised function warnings
 apropos-do-all t                        ; make `apropos' more useful
 compilation-always-kill t               ; kill compilation process before starting another
 compilation-ask-about-save nil          ; save all buffers on `compile'
 compilation-scroll-output t             ; scroll to end of compilation output
 confirm-nonexistent-file-or-buffer t    ; confirm nonexisting files/buffers when opening
 idle-update-delay 2                     ; update ui less often (performance)
 warning-minimum-level :error            ; don't show warnings only errors
 ;; keep the point out of the minibuffer
 minibuffer-prompt-properties '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))

 (set-terminal-coding-system 'utf-8)
 (set-keyboard-coding-system 'utf-8)
 (prefer-coding-system 'utf-8)
 (load-library "iso-transl")


(setq-default
 isearch-allow-scroll t                 ; Allow scrolling in an isearch session
 lazy-highlight-cleanup nil             ; Leave highlights after an isearch session
 lazy-highlight-initial-delay 0)        ; Start highlighting immediately


(require 'vc-hooks)

;; Always follow symlinks to files under source-control. dont ask.
(setq vc-follow-symlinks t)
;; Modifications related to whitespace management

;; Disable tab indentation
(setq-default indent-tabs-mode nil)

;; Remove trailing whitespace before save.
(add-hook 'before-save-hook 'delete-trailing-whitespace)

(setq
 auto-save-default nil
 backup-inhibited t
 confirm-nonexistent-file-or-buffer nil
 create-lockfiles nil
 mouse-wheel-progressive-speed nil)


(define-key global-map [remap list-buffers] 'ibuffer)



(winner-mode +1)



(global-set-key (kbd "C-x C-c") 'save-buffers-kill-emacs)

 ;; Always ask for y/n keypress instead of typing out 'yes' or 'no'
(autoload 'ibuffer "ibuffer")

(fset 'yes-or-no-p 'y-or-n-p)


 ;; Emacs writes backup files to `filename~` by default. This is messy,
 ;; so let's tell it to write them to `~/.emacs.d/bak` instead.
 ;; If you have an accident, check this directory - you might get lucky.
(setq backup-directory-alist   ;; Save backups in $(pwd)/.bak
      '(("." . ".bak"))        ;;
      )

(setq version-control t
      backup-by-copying t      ;; Copy-on-write-esque
      kept-new-versions 64     ;; Indeliable-ink-esque
      kept-old-versions 0      ;;
      delete-old-versions t    ;;
      )



 ;; Automatically save buffers before launching M-x compile and friends,
 ;; instead of asking you if you want to save.
 (setq compilation-ask-about-save nil)

 ;; Make the selection work like most people expect.
 (delete-selection-mode 1)
 (transient-mark-mode t)

(global-set-key (kbd "DEL") 'backward-delete-char)

;; Enable `downcase-region' and `upcase-region'
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)


 ;; Automatically update unmodified buffers whose files have changed.
 (global-auto-revert-mode 1)

 ;; If available, use `xdg-open' to open URLs.
 (when (core/is-exec "xdg-open")
   (setq-default
    browse-url-browser-function (quote browse-url-generic)
    browse-url-generic-program "xdg-open"))

 ;; Make compilation buffers scroll to follow the output, but stop scrolling
 ;; at the first error.
 (setq compilation-scroll-output 'first-error)

(setq-default uniquify-buffer-name-style 'forward)

(global-set-key "\C-C\C-e" 'eval-buffer)


(global-unset-key [(control z)])
(global-unset-key [(control x)(control z)])
(global-unset-key (kbd "<f1>"))
(global-unset-key (kbd "<f2>"))
(global-unset-key (kbd "<f3>"))
(global-unset-key (kbd "<f4>"))
(global-unset-key (kbd "<f5>"))
(global-unset-key (kbd "<f6>"))
(global-unset-key (kbd "<f7>"))
(global-unset-key (kbd "<f8>"))
(global-unset-key (kbd "<f9>"))
(global-unset-key (kbd "<f10>"))
(global-unset-key (kbd "<f11>"))
(global-unset-key (kbd "<f12>"))

(dotimes (n 10)
  (global-unset-key (kbd (format "C-%d" n)))
  (global-unset-key (kbd (format "M-%d" n)))
  )

  #+END_SRC
*** recentf
#+BEGIN_SRC emacs-lisp
(use-package recentf

  :config
  (setq recentf-save-file (concat dotfiles-etc-dir "recentf")
      recentf-max-menu-items 0
      recentf-max-saved-items 300)
  (recentf-mode))

#+END_SRC

*** vlf
#+BEGIN_SRC emacs-lisp
(use-package vlf )
#+END_SRC
*** scratch
  #+BEGIN_SRC emacs-lisp
(use-package scratch )
  #+END_SRC
**** persistent-scratch
 #+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
:init
(persistent-scratch-setup-default))
 #+END_SRC
**** unkillable-scratch
   #+BEGIN_SRC emacs-lisp
(use-package unkillable-scratch
  :ensure t
  :config
  (unkillable-scratch t)
  (setq unkillable-scratch-do-not-reset-scratch-buffer t))
   #+END_SRC

*** desktop-environment
 #+BEGIN_SRC emacs-lisp
(use-package desktop-environment )
 #+END_SRC

*** visual-fill-column
#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
   :commands visual-fill-column-mode
   :config
   (setq-default
     visual-fill-column-center-text t
     visual-fill-column-width
     ;; take Emacs 26 line numbers into account
     (+ (if (boundp 'display-line-numbers) 6 0)
        fill-column)))
#+END_SRC
*** company
  #+BEGIN_SRC emacs-lisp
   (use-package company

     :commands company-mode
     :config
     ;; Enable company-mode globally.
     (global-company-mode)
     ;; Except when you're in term-mode.
     (setq company-global-modes '(not term-mode))
     ;; Give Company a decent default configuration.
     (setq company-minimum-prefix-length 2
           company-selection-wrap-around t
           company-show-numbers t
           company-tooltip-align-annotations t
           company-require-match nil
           company-dabbrev-downcase nil
           company-dabbrev-ignore-case nil)
     ;; Sort completion candidates that already occur in the current
     ;; buffer at the top of the candidate list.
     (setq company-transformers '(company-sort-by-occurrence))
     ;; Show documentation where available for selected completion
     ;; after a short delay.
     (use-package company-quickhelp
       :config
       (setq company-quickhelp-delay 1)
       (company-quickhelp-mode 1))
     ;; Add a completion source for emoji. ðŸ˜¸
     (use-package company-emoji
       :config
       (company-emoji-init))

     ;; Use C-\ to activate the Company autocompleter.
     ;; We invoke company-try-hard to gather completion candidates from multiple
     ;; sources if the active source isn't being very forthcoming.
     (use-package company-try-hard
       :commands company-try-hard)

   )
  #+END_SRC

*** historian
#+BEGIN_SRC emacs-lisp
(use-package historian )

#+END_SRC
*** ivy
**** setup
 #+BEGIN_SRC emacs-lisp
(use-package ivy
   :config
  (setq ivy-height 15                                  ; slightly longer ivy completions list
        ivy-wrap t                                     ; wrap around at end of completions list
        ivy-fixed-height-minibuffer t                  ; use consistent height for ivy
        projectile-completion-system 'ivy              ; use ivy for projectile
        smex-completion-method 'ivy                    ; use ivy for smex
        ivy-initial-inputs-alist nil                   ; don't use ^ as initial input
        ivy-format-function #'ivy-format-function-line ; highlight til EOL
        ivy-use-virtual-buffers nil                    ; dont' show recent files in switch-buffer
        ivy-virtual-abbreviate 'full                   ; show full path if showing virtual buffer
        ivy-magic-slash-non-match-action nil           ; disable magic slash on non-match
        ivy-on-del-error-function nil                  ; don't quit minibuffer on delete-error
        ivy-use-selectable-prompt t)                   ; allow input prompt value to be selectable

  (after! magit     (setq magit-completing-read-function #'ivy-completing-read))
  (after! yasnippet (add-to-list 'yas-prompt-functions #'+ivy-yas-prompt nil #'eq))

)
#+END_SRC
**** ivy-historian
 #+BEGIN_SRC emacs-lisp
(use-package ivy-historian )
 #+END_SRC
**** ivy-xref
 #+BEGIN_SRC emacs-lisp
(use-package ivy-xref
  :ensure t
  :init (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
 #+END_SRC
**** ivy-rich
 #+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :demand t
  :init
(ivy-rich-mode +1)
  :config
   (defun ivy-rich-switch-buffer-icon (candidate)
     (with-current-buffer
   	  (get-buffer candidate)
	(let ((icon (all-the-icons-icon-for-mode major-mode)))
	  (if (symbolp icon)
	      (all-the-icons-icon-for-mode 'fundamental-mode)
	    icon))))

(setq ivy-rich--display-transformers-list
      '(ivy-switch-buffer
        (:columns
         ((ivy-rich-switch-buffer-icon :width 2)
          (ivy-rich-candidate (:width 30))
          (ivy-rich-switch-buffer-size (:width 7))
          (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right))
          (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))
          (ivy-rich-switch-buffer-project (:width 15 :face success))
          (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))
         :predicate
         (lambda (cand) (get-buffer cand)))))

)

(setq ivy-rich-path-style 'abbrev)

 #+END_SRC
*** smex
#+BEGIN_SRC emacs-lisp
(use-package smex
  :config
(setq smex-save-file (concat dotfiles-cache-dir "/smex-items"))
(smex-initialize))

#+END_SRC
*** counsel
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :hook
  (after-init . ivy-mode)
  :diminish ivy-mode
  :bind
  (
   ("M-x" . counsel-M-x)
   ("C-x x" . counsel-M-x)
   ("<execute>" . counsel-M-x)
   ("C-x i" . counsel-imenu)
   ("C-x b" . ivy-switch-buffer)
   ("C-x B" . counsel-switch-buffer-other-window)
   ("C-x k" . kill-buffer)
   ("C-x C-f" . counsel-find-file)
   ("C-x l" . counsel-locate)
   :map ivy-minibuffer-map
   ("C-o" . ivy-occur)
   ("<return>" . ivy-alt-done)
   ("M-<return>" . ivy-immediate-done)
   :map read-expression-map
   ("C-r" . counsel-minibuffer-history))
  :custom
  (counsel-find-file-at-point t)
  (ivy-use-virtual-buffers nil)
  (ivy-display-style 'fancy)
  (ivy-use-selectable-prompt t)
  (ivy-re-builders-alist
   '((ivy-switch-buffer . ivy--regex-plus)
     (swiper . ivy--regex-plus)
     (t . ivy--regex-fuzzy)))
  :config
(defun my/counsel-switch-buffer-other-window ()
(interactive)
(ace-window nil)
(counsel-switch-buffer))
  (ivy-set-actions
   t
   '(("I" insert "insert")))
  (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))
#+END_SRC
*** swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :bind
  (("C-s" . swiper)
   ("C-r" . counsel-grep-or-swiper)
   :map swiper-map
   ("M-q" . swiper-query-replace)
   ("C-l". swiper-recenter-top-bottom))
  :custom
  (counsel-grep-swiper-limit 20000)
  (counsel-rg-base-command
   "rg -i -M 120 --no-heading --line-number --color never %s .")
  (counsel-grep-base-command
   "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))

#+END_SRC
*** grep
**** wgrep
 #+BEGIN_SRC emacs-lisp
(use-package wgrep
  :commands
  wgrep-change-to-wgrep-mode
  ivy-wgrep-change-to-wgrep-mode)

 #+END_SRC
**** deadgrep
 #+BEGIN_SRC emacs-lisp
(use-package deadgrep
  :bind* (("M-s" . deadgrep)))
 #+END_SRC
*** yasnippets
  #+BEGIN_SRC emacs-lisp
 (use-package yasnippet
   :config
   (yas-global-mode 1))
  #+END_SRC
**** yasnippet-snippets
 #+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
:config
(require 'yasnippet-snippets))

 #+END_SRC
**** auto-yasnippet
 #+BEGIN_SRC emacs-lisp
(use-package auto-yasnippet
:config
(require 'auto-yasnippet))
 #+END_SRC
*** git
  #+BEGIN_SRC emacs-lisp
 (use-package magit
   :commands magit-status
   :bind ("C-x g" . magit-status))


 (use-package gist )
 (use-package git-timemachine )


  #+END_SRC
*** super-save
#+BEGIN_SRC emacs-lisp
(use-package super-save )
#+END_SRC
** Navigation
*** config
 #+BEGIN_SRC emacs-lisp
(setq scroll-error-top-bottom t)

(defun smart-beginning-of-line ()
  "Move point to first non-whitespace character or beginning-of-line."
  (interactive "^")
  (let ((oldpos (point)))
    (back-to-indentation)
    (and (= oldpos (point))
         (beginning-of-line))))
(global-set-key (kbd "<home>") 'smart-beginning-of-line)
(global-set-key (kbd "C-a") 'smart-beginning-of-line)

;; Consider CamelCase chunks as words when navigating.
(global-subword-mode 1)

;; Use C-x M-p to kill the buffer in the other window, revealing
;; the next buffer in the stack.
(global-set-key
 (kbd "C-x M-p")
 (lambda () (interactive)
   (save-excursion
     (other-window 1)
     (quit-window))))
 #+END_SRC
*** avy
#+BEGIN_SRC emacs-lisp
(use-package avy
   :config
   (setq avy-background t)
   (setq avy-style 'at-full))
#+END_SRC

*** anzu
#+BEGIN_SRC emacs-lisp
(use-package anzu

  :config
  (global-anzu-mode 1)
  ;; Anzu provides a version of `query-replace' and friends which give visual
  ;; feedback when composing regexps. Let's replace the regular versions.
  :bind(("C-%" . anzu-query-replace-at-cursor)
        ("M-%" . anzu-query-replace)
        ("C-M-%" . anzu-query-replace-regexp))
  :diminish anzu-mode)
#+END_SRC
*** ace-window
  #+BEGIN_SRC emacs-lisp :tangle
(use-package ace-window

  :config
  (setq aw-scope 'frame))

 (defun module/previous-window ()
   (interactive)
   (-let [current (selected-window)]
     (cond
      ((eq module/--last-window current)
       (ace-select-window))

      ((window-live-p module/--last-window)
       (select-window module/--last-window))

      (t
       (ace-select-window)))
     (setq module/--last-window current)))

 (defun module/select-window ()
   (interactive)
   (setq module/--last-window (selected-window))
   (ace-select-window))

 (setq module/--last-window (selected-window))

 (global-set-key (kbd "C-x o") 'module/previous-window)
 (global-set-key (kbd "C-x C-o") 'module/select-window)
 (global-set-key (kbd "C-x \\") 'ace-swap-window)


  #+END_SRC
*** windmove
#+BEGIN_SRC emacs-lisp
(use-package windmove )
#+END_SRC

*** buffer-move
#+BEGIN_SRC emacs-lisp
(use-package buffer-move )
#+END_SRC

*** transpose-frame
#+BEGIN_SRC emacs-lisp
(use-package transpose-frame )
#+END_SRC

*** beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
   :init
   (beacon-mode 1))
#+END_SRC
*** dired
**** dired-k
   #+BEGIN_SRC emacs-lisp
 (setq global-auto-revert-non-file-buffers t)
 (setq auto-revert-verbose nil)

 (setq ;; Always copy/delete recursively
       dired-recursive-copies  'always
       dired-recursive-deletes 'top
       ;; files
       image-dired-dir (concat user-emacs-directory "image-dired/")
       image-dired-db-file (concat user-emacs-directory "image-dired/db.el")
       image-dired-gallery-dir (concat user-emacs-directory "gallery/")
       image-dired-temp-image-file (concat user-emacs-directory "temp-image")
       image-dired-temp-rotate-image-file (concat user-emacs-directory "temp-rotate-image"))


 (use-package dired-k
   :after dired
   :config
   (setq dired-k-style 'git)

   (defun +dired*dired-k-highlight (orig-fn &rest args)
     "Butt out if the requested directory is remote (i.e. through tramp)."
     (unless (file-remote-p default-directory)
       (apply orig-fn args)))
   (advice-add #'dired-k--highlight :around #'+dired*dired-k-highlight)

   (add-hook 'dired-initial-position-hook #'dired-k)
   (add-hook 'dired-after-readin-hook #'dired-k-no-revert))


 ;; A function for deleting the file being edited.
 ;; This one is a bit dangerous, even with the yes/no question, so
 ;; it's not bound to any key by default.
 ;; Run it using M-x delete-current-buffer-file.
 (defun delete-current-buffer-file ()
   "Removes file connected to current buffer and kills buffer."
   (interactive)
   (let ((filename (buffer-file-name))
         (buffer (current-buffer))
         (name (buffer-name)))
     (if (not (and filename (file-exists-p filename)))
         (ido-kill-buffer)
       (when (yes-or-no-p "Are you sure you want to remove this file? ")
         (delete-file filename)
         (kill-buffer buffer)
         (message "File '%s' successfully removed" filename)))))

 ;; And a function for renaming the file being edited, bound to C-x C-r.
 (defun rename-current-buffer-file ()
   "Renames current buffer and file it is visiting."
   (interactive)
   (let ((name (buffer-name))
         (filename (buffer-file-name)))
     (if (not (and filename (file-exists-p filename)))
         (error "Buffer '%s' is not visiting a file!" name)
       (let ((new-name (read-file-name "New name: " filename)))
         (if (get-buffer new-name)
             (error "A buffer named '%s' already exists!" new-name)
           (rename-file filename new-name 1)
           (rename-buffer new-name)
           (set-visited-file-name new-name)
           (set-buffer-modified-p nil)
           (message "File '%s' successfully renamed to '%s'"
                    name (file-name-nondirectory new-name)))))))
 (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

(require 'dired)

(setq wdired-use-dired-vertical-movement 'sometimes)
(define-key dired-mode-map (kbd "C-s") #'dired-isearch-filenames)

    #+END_SRC
**** dired-hide-dotfiles
  #+BEGIN_SRC emacs-lisp
 (use-package dired-hide-dotfiles
 :config
 (defun my-dired-mode-hook ()
   "My `dired' mode hook."
   ;; To hide dot-files by default
   (dired-hide-dotfiles-mode)

   ;; To toggle hiding
   (define-key dired-mode-map "." #'dired-hide-dotfiles-mode))

 (add-hook 'dired-mode-hook #'my-dired-mode-hook))
 #+END_SRC
**** dired-imenu
 #+BEGIN_SRC emacs-lisp
(use-package dired-imenu :ensure t)
 #+END_SRC
**** dired-rsync
 #+BEGIN_SRC emacs-lisp
(use-package dired-rsync
  :config
  (bind-key "C-c C-r" 'dired-rsync dired-mode-map))
 #+END_SRC

**** dired-hack-utils
 #+BEGIN_SRC emacs-lisp
(use-package dired-hacks-utils)
 #+END_SRC
**** dired-filter
 #+BEGIN_SRC emacs-lisp
(use-package dired-filter)
 #+END_SRC
**** dired-avfs
 #+BEGIN_SRC emacs-lisp
(use-package dired-avfs)
 #+END_SRC
**** dired-open
 #+BEGIN_SRC emacs-lisp
(use-package dired-open)
 #+END_SRC
**** dired-narrow
 #+BEGIN_SRC emacs-lisp
(use-package dired-narrow)
 #+END_SRC
**** dired-subtree
 #+BEGIN_SRC emacs-lisp
(use-package dired-subtree)
 #+END_SRC
**** dired-collapse
 #+BEGIN_SRC emacs-lisp
(use-package dired-collapse)
 #+END_SRC
** Editing
*** config
 #+BEGIN_SRC emacs-lisp :tangle
(setq bookmark-save-flag 1) ;; save after every change

(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
      select-enable-clipboard t
      select-enable-primary t)

(setq-default
 fill-column 100                  ; set line-wrapping column to 100
 word-wrap t                     ; enable word wrap so lines are wrapped at nearest space
 truncate-lines t
 truncate-partial-width-windows 50)

(setq-default
 indent-tabs-mode nil         ; don't insert tabs by default
 require-final-newline t      ; ensure newline exists at end of file
 tab-always-indent t          ; always indent line when pressing TAB (don't add tab character)
 tab-width 2                  ; default tab width of 2 characters
 tabify-regexp "^\t* [ \t]+") ; only tabify initial whitespace when converting to tabifying

(setq-default
 vc-follow-symlinks t                             ; automatically follow symlinks
 save-interprogram-paste-before-kill t)           ; save clipboard contents into kill-ring before replacing them
(global-auto-revert-mode t)                       ; revert changed buffers
(show-paren-mode)                                 ; highlight matching parenthesis
(push '("/LICENSE$" . text-mode) auto-mode-alist) ; license files should be handled in text mode

 ;; whitespace-mode
(setq-default
 whitespace-line-column fill-column
 whitespace-style
 '(face indentation tabs tab-mark spaces space-mark newline newline-mark trailing lines-tail)
 whitespace-display-mappings
 '((tab-mark ?\t [?â€º ?\t])
   (newline-mark ?\n [?Â¬ ?\n])
   (space-mark ?\  [?Â·] [?.])))

(setq-default
 scroll-conservatively 1001             ; always scroll to the point no matter how far away (don't recenter)
 scroll-margin 3                        ; don't automatically scroll to retain a margin
 scroll-preserve-screen-position t)     ; preserve point location on screen when scrolling

 (setq require-final-newline t)

 (setq echo-keystrokes 0.001)

 (setq-default indent-tabs-mode nil)   ;; don't use tabs to indent
 (setq-default tab-width 8)            ;; but maintain correct appearance


 (require 'super-save)
 ;; add integration with ace-window
 (add-to-list 'super-save-triggers 'ace-window)
 (super-save-mode +1)


 (setq tab-always-indent 'complete)

 (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                          try-expand-dabbrev-all-buffers
                                          try-expand-dabbrev-from-kill
                                          try-complete-file-name-partially
                                          try-complete-file-name
                                          try-expand-all-abbrevs
                                          try-expand-list
                                          try-expand-line
                                          try-complete-lisp-symbol-partially
                                          try-complete-lisp-symbol))

 (global-auto-revert-mode t)

 (windmove-default-keybindings)

 (require 'tramp)
 ;; keep in mind known issues with zsh - see emacs wiki
 (setq tramp-default-method "ssh")

 (setq ispell-program-name "aspell" ; use aspell instead of ispell
       ispell-extra-args '("--sug-mode=ultra"))

 ;; enable narrowing commands
 (put 'narrow-to-region 'disabled nil)
 (put 'narrow-to-page 'disabled nil)
 (put 'narrow-to-defun 'disabled nil)

 ;; enabled change region case commands
 (put 'upcase-region 'disabled nil)
 (put 'downcase-region 'disabled nil)

 ;; enable erase-buffer command
 (put 'erase-buffer 'disabled nil)


 (defun indent-buffer ()
   (interactive)
   (indent-region (point-min) (point-max)))
 (global-set-key (kbd "C-c <tab>") 'indent-buffer)

 #+END_SRC

*** browse-kill-ring
#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring)
 (require 'browse-kill-ring)
 (browse-kill-ring-default-keybindings)
 (global-set-key (kbd "s-y") 'browse-kill-ring)
#+END_SRC
*** markdown-mode
  #+BEGIN_SRC emacs-lisp
 (use-package markdown-mode
   :commands markdown-mode
   :mode (("\\.markdown$" . markdown-mode)
          ("\\.md$" . markdown-mode))
   :config
   (add-hook 'markdown-mode-hook 'visual-line-mode))
  #+END_SRC
**** gihub-flavored-markdown
 #+BEGIN_SRC emacs-lisp
(use-package ox-gfm)
 #+END_SRC
*** flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
   :config
 (global-set-key (kbd "M-n") 'next-error)
 (global-set-key (kbd "M-p") 'previous-error)
   ;; Start it automatically for all modes except ELisp mode,
   (add-hook 'find-file-hook
             (lambda ()
               (when (not (equal 'emacs-lisp-mode major-mode))
                 (flycheck-mode)))))

#+END_SRC
**** flycheck-color-mode-line
 #+BEGIN_SRC emacs-lisp
(use-package flycheck-color-mode-line
   :config
   (with-eval-after-load "flycheck"
     (setq flycheck-highlighting-mode 'symbols)
     (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
 #+END_SRC
*** expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
   :commands er/expand-region)
#+END_SRC
*** smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens)
#+END_SRC
*** projectile
   #+BEGIN_SRC emacs-lisp
(use-package projectile
  :custom
  (projectile-use-git-grep t)
  (projectile-create-missing-test-files t)
  (projectile-completion-system 'ivy)
  (projectile-switch-project-action  #'projectile-commander)
  (projectile-discover-projects-in-search-path "~/org/projects")
  :config
  (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
  (projectile-mode +1)
  (counsel-projectile-mode +1)
  (def-projectile-commander-method ?S
    "Run a search in the project"
    (counsel-projectile-rg))
  (def-projectile-commander-method ?s
    "Open a *eshell* buffer for the project."
    (projectile-run-eshell))
  (def-projectile-commander-method ?d
    "Open project root in dired."
    (projectile-dired))
  (def-projectile-commander-method ?g
    "Show magit status."
    (magit-status)))

(use-package counsel-projectile
  :after ivy projectile
  :bind (("C-c s" . counsel-projectile-rg)))

(use-package ibuffer-projectile
  :config
  (add-hook 'ibuffer-hook
            (lambda ()
              (ibuffer-projectile-set-filter-groups)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic)))))
   #+END_SRC
** Help
*** which-key
  #+BEGIN_SRC emacs-lisp
(use-package which-key

  :bind ("C-h C-k" . which-key-show-top-level)
  :config
  (setq which-key-sort-order #'which-key-prefix-then-key-order
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-idle-delay 0.0
        which-key-special-keys nil
        which-key-min-display-lines 7)
  (set-face-attribute 'which-key-local-map-description-face nil :weight 'bold)
  (which-key-setup-side-window-bottom)
  (which-key-mode)
  :diminish which-key-mode)
  #+END_SRC
*** discover-my-major
#+BEGIN_SRC emacs-lisp
(use-package discover-my-major

  :commands (discover-my-major discover-my-mode)
  :bind ("<f1>" . discover-my-major))
#+END_SRC
** org
  #+BEGIN_SRC emacs-lisp
 (use-package org

   :ensure org-plus-contrib
   :bind(("C-x C-k" . org-cut-subtree))
   :config
   ;; Stop org-mode from highjacking shift-cursor keys.
   (setq org-replace-disputed-keys t)
   ;; Always use visual-line-mode in org-mode, and wrap it at column 80.
   (add-hook
    'org-mode-hook
    (lambda ()
      (visual-line-mode 1))))
   #+END_SRC
*** org-cliplink
#+BEGIN_SRC emacs-lisp
(use-package org-cliplink)
#+END_SRC
*** org-download
#+BEGIN_SRC emacs-lisp
 (use-package org-download
 :init
 (setq org-download-method 'attach)
 (setq org-image-actual-width 600))

#+END_SRC
*** org-journal
#+BEGIN_SRC emacs-lisp
(use-package org-journal
   :init
   (setq org-journal-file-format "%Y-%m-%d.org"))
#+END_SRC
