:HIDDEN:
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+PROPERTY: header-args :tangle config.el
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD_EXTRA: <style>div#content { max-width: 2000px; }</style>
:END:
#+TITLE: Emacs Configuration
#+TODO: ACTIVE | DISABLED

* Core
** Package
 #+BEGIN_SRC emacs-lisp
 ;; `(online?)` is a function that tries to detect whether you are online.
 ;; We want to refresh our package list on Emacs start if we are.
 (require 'cl)
 (defun online? ()
   (if (and (functionp 'network-interface-list)
            (network-interface-list))
       (some (lambda (iface) (unless (equal "lo" (car iface))
                          (member 'up (first (last (network-interface-info
                                                    (car iface)))))))
             (network-interface-list))
     t))

 ;; Emacs comes with a package manager for installing more features.
 ;; The default package repository doesn't contain much, so we tell it
 ;; to use MELPA as well.
 (setq package-user-dir (concat dotfiles-dir "elpa"))
 (require 'package)
 (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
 (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

 ;; To get the package manager going, we invoke its initialise function.
 (package-initialize)

 ;; If we're online, we attempt to fetch the package directories if
 ;; we don't have a local copy already. This lets us start installing
 ;; packages right away from a clean install.
 (when (online?)
   (unless package-archive-contents (package-refresh-contents)))

 ;; `Paradox' is an enhanced interface for package management, which also
 ;; provides some helpful utility functions we're going to be using
 ;; extensively. Thus, the first thing we do is install it if it's not there
 ;; already.
 (when (not (package-installed-p 'paradox))
   (package-install 'paradox))

 ;; We're going to be using `use-package' to manage our dependencies.
 ;; In its simplest form, we can call eg. `(use-package lolcode-mode)'
 ;; to install the `lolcode-mode' package. We'd also declare one or more
 ;; entry points so the module isn't loaded unneccesarily at startup.
 ;; For instance, `(use-package my-module :commands (my-function))' will
 ;; defer loading `my-module' until you actually call `(my-function)'.
 ;;
 ;; Read about it in detail at https://github.com/jwiegley/use-package

 ;; First, we make sure it's installed, using a function provided by
 ;; Paradox, which we've just installed the hard way.
 (paradox-require 'use-package)

 ;; Next, we load it so it's always available.
 (require 'use-package)

 ;; Finally, we enable `use-package-always-ensure' which makes
 ;; use-package install every declared package automatically from ELPA,
 ;; instead of expecting you to do it manually.
 (setq use-package-always-ensure t)

   #+END_SRC
** Libraries
*** config
 #+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'cl-lib))

 (defun core/font-lock-replace-symbol (mode reg sym)
   "Given a major mode `mode', replace the regular expression `reg' with
 the symbol `sym' when rendering."
   (font-lock-add-keywords
    mode `((,reg
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      ,sym 'decompose-region)))))))
 (defun core/exec (command)
   "Run a shell command and return its output as a string, whitespace trimmed."
   (s-trim (shell-command-to-string command)))

 (defun core/exec-with-rc (command &rest args)
   "Run a shell command and return a list containing two values: its return
 code and its whitespace trimmed output."
   (with-temp-buffer
     (list (apply 'call-process command nil (current-buffer) nil args)
           (s-trim (buffer-string)))))

 (defun core/is-exec (command)
   "Returns true if `command' is an executable on the system search path."
   (f-executable? (s-trim (shell-command-to-string (s-concat "which " command)))))

 (defun core/resolve-exec (command)
   "If `command' is an executable on the system search path, return its absolute path.
 Otherwise, return nil."
   (-let [path (s-trim (shell-command-to-string (s-concat "which " command)))]
     (when (f-executable? path) path)))

 (defun core/exec-if-exec (command args)
   "If `command' satisfies `core/is-exec', run it with `args' and return its
 output as per `core/exec'. Otherwise, return nil."
   (when (core/is-exec command) (core/exec (s-concat command " " args))))



 (defun core/getent (user)
   "Get the /etc/passwd entry for the user `user' as a list of strings,
 or nil if there is no such user. Empty fields will be represented as nil,
 as opposed to empty strings."
   (-let [ent (core/exec (s-concat "getent passwd " user))]
     (when (not (s-blank? ent))
       (-map (lambda (i) (if (s-blank? i) nil i))
             (s-split ":" ent)))))

 (defun core/user-full-name ()
   "Guess the user's full name. Returns nil if no likely name could be found."
   (or (core/exec-if-exec "git" "config --get user.name")
       (elt (core/getent (getenv "USER")) 4)))

 (defun core/user-email ()
   "Guess the user's email address. Returns nil if none could be found."
   (or (core/exec-if-exec "git" "config --get user.email")
       (getenv "EMAIL")))

(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))


  (eval-and-compile

    (defun my/resolve-hook-forms (hooks)
      (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
               for hook in (doom-enlist (doom-unquote hooks))
               if (eq (car-safe hook) 'quote)
                collect (cadr hook)
               else if quoted-p
                collect hook
               else collect (intern (format "%s-hook" (symbol-name hook)))))

    (defvar my/transient-counter 0)
    (defmacro add-transient-hook! (hook &rest forms)
      "Attaches transient forms to a HOOK.

    HOOK can be a quoted hook or a sharp-quoted function (which will be advised).

    These forms will be evaluated once when that function/hook is first invoked,
    then it detaches itself."
      (declare (indent 1))
      (let ((append (eq (car forms) :after))
            (fn (intern (format "my/transient-hook-%s" (cl-incf my/transient-counter)))))
        `(when ,hook
           (fset ',fn
                 (lambda (&rest _)
                   ,@forms
                   (cond ((functionp ,hook) (advice-remove ,hook #',fn))
                         ((symbolp ,hook)   (remove-hook ,hook #',fn)))
                   (unintern ',fn nil)))
           (cond ((functionp ,hook)
                  (advice-add ,hook ,(if append :after :before) #',fn))
                 ((symbolp ,hook)
                  (add-hook ,hook #',fn ,append)))))))

  (defmacro add-hook! (&rest args)
    "A convenience macro for `add-hook'. Takes, in order:

    1. Optional properties :local and/or :append, which will make the hook
       buffer-local or append to the list of hooks (respectively),
    2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
       a quoted hook variable or a quoted list of hook variables. If unquoted, the
       hooks will be resolved by appending -hook to each symbol.
    3. A function, list of functions, or body forms to be wrapped in a lambda.

  Examples:
      (add-hook! 'some-mode-hook 'enable-something)
      (add-hook! some-mode '(enable-something and-another))
      (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
      (add-hook! (one-mode second-mode) 'enable-something)
      (add-hook! :append (one-mode second-mode) 'enable-something)
      (add-hook! :local (one-mode second-mode) 'enable-something)
      (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
      (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

  Body forms can access the hook's arguments through the let-bound variable
  `args'."
    (declare (indent defun) (debug t))
    (let ((hook-fn 'add-hook)
          append-p local-p)
      (while (keywordp (car args))
        (pcase (pop args)
          (:append (setq append-p t))
          (:local  (setq local-p t))
          (:remove (setq hook-fn 'remove-hook))))
      (let ((hooks (my/resolve-hook-forms (pop args)))
            (funcs
             (let ((val (car args)))
               (if (memq (car-safe val) '(quote function))
                   (if (cdr-safe (cadr val))
                       (cadr val)
                     (list (cadr val)))
                 (list args))))
            forms)
        (dolist (fn funcs)
          (setq fn (if (symbolp fn)
                       `(function ,fn)
                     `(lambda (&rest _) ,@args)))
          (dolist (hook hooks)
            (push (cond ((eq hook-fn 'remove-hook)
                         `(remove-hook ',hook ,fn ,local-p))
                        (t
                         `(add-hook ',hook ,fn ,append-p ,local-p)))
                  forms)))
        `(progn ,@(nreverse forms)))))

  (defmacro remove-hook! (&rest args)
    "Convenience macro for `remove-hook'. Takes the same arguments as
  `add-hook!'."
    `(add-hook! :remove ,@args))

 #+END_SRC
*** packages
**** async
 #+BEGIN_SRC emacs-lisp
(use-package async :demand t
    :config
    (dired-async-mode 1))
 #+END_SRC
**** subr-x
 #+BEGIN_SRC emacs-lisp
(use-package subr-x :demand t :ensure nil)

 #+END_SRC

**** dash
 #+BEGIN_SRC emacs-lisp
(use-package dash
  :ensure t
  :config
  (dash-enable-font-lock))
(use-package dash-functional
  :ensure t)
 #+END_SRC

**** f
 #+BEGIN_SRC emacs-lisp
(use-package f
  :ensure t)
 #+END_SRC

**** s
  #+BEGIN_SRC emacs-lisp
(use-package s
  :ensure t)
  #+END_SRC

**** ht
  #+BEGIN_SRC emacs-lisp
(use-package ht
  :ensure t)
  #+END_SRC

**** a
 #+begin_src emacs-lisp
(require 'let-alist)
(use-package a
  :ensure t)
 #+end_src

**** persistent-soft
 #+BEGIN_SRC emacs-lisp
(use-package persistent-soft
  :ensure t)
 #+END_SRC

** Linux
*** config
 #+BEGIN_SRC emacs-lisp
(setq x-gtk-use-system-tooltips nil)
  #+END_SRC
*** packages
**** exec-path-from-shell
 #+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
:config
(exec-path-from-shell-initialize))
 #+END_SRC
**** counsel
  #+BEGIN_SRC emacs-lisp
  (use-package counsel
    :config
    (push (concat (getenv "HOME") "/.local/share/applications/") counsel-linux-apps-directories)
     (defun my/counsel-linux-app-format-function (name comment exec)
       "Default Linux application name formatter.
   NAME is the name of the application, COMMENT its comment and EXEC
   the command to launch it."
       (format "% -45s %s"
               (propertize name 'face 'font-lock-builtin-face)
               (or comment "")))
     (setq counsel-linux-app-format-function #'my/counsel-linux-app-format-function))


  #+END_SRC

** DISABLED macOS
*** DISABLED config
  #+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/core/core-macos.el
 (setq ns-function-modifier 'hyper)

 (defun user-swap-meta-and-super ()
   "Swap the mapping of Meta and Super.
 Very useful for people using their Mac with a
 Windows external keyboard from time to time."
   (interactive)
   (if (eq mac-command-modifier 'super)
       (progn
         (setq mac-command-modifier 'meta)
         (setq mac-option-modifier 'super)
         (message "Command is now bound to META and Option is bound to SUPER."))
     (setq mac-command-modifier 'super)
     (setq mac-option-modifier 'meta)
     (message "Command is now bound to SUPER and Option is bound to META.")))

 (menu-bar-mode +1)

 (when (fboundp 'set-fontset-font)
   (set-fontset-font t 'unicode "Apple Color Emoji" nil 'prepend))

(setq locate-make-command-line (lambda (s) `("mdfind" "-name" ,s)))

(setq mac-emulate-three-button-mouse t)

(setq shift-select-mode t)

(global-set-key (kbd "<s-up>")    'beginning-of-buffer)
(global-set-key (kbd "<s-down>")  'end-of-buffer)
(global-set-key (kbd "<s-left>")  'move-beginning-of-line)
(global-set-key (kbd "<s-right>") 'move-end-of-line)

(define-key global-map (kbd "s-+") 'text-scale-increase)
(define-key global-map (kbd "s--") 'text-scale-decrease)

(global-set-key (kbd "s-f") 'isearch-forward-regexp)

(global-set-key (kbd "<M-up>") 'backward-paragraph)
(global-set-key (kbd "<M-down>") 'forward-paragraph)

(global-set-key (kbd "M-<backspace>") 'backward-kill-word)

(global-set-key (kbd "s-w") 'kill-this-buffer)

(setq delete-by-moving-to-trash t)

(setq ns-right-alternate-modifier nil)

(setq mac-option-modifier 'meta)
(setq mac-command-modifier 'super)

(global-set-key [(super a)] 'mark-whole-buffer)
(global-set-key [(super c)] 'kill-ring-save)
(global-set-key [(super g)] 'isearch-repeat-forward)
(global-set-key [(super l)] 'goto-line)
(global-set-key [(super q)] 'save-buffers-kill-terminal)
(global-set-key [(super s)] 'save-buffer)
(global-set-key [(super v)] 'yank)
(global-set-key [(super x)] 'kill-region)
(global-set-key [(super w)] (lambda ()
                              (interactive)
                              (kill-buffer (current-buffer))))
(global-set-key [(super z)] 'undo)

(setq visible-bell nil)

(setq mac-right-alternate-modifier nil)

(global-set-key (kbd "s-K") nil)
(global-set-key (kbd "s-k") nil)
(add-hook 'prog-mode-hook
          (lambda ()
            ;; compile short cuts
            (define-key (current-local-map) (kbd "s-K") 'compile)
            (define-key (current-local-map) (kbd "s-k") 'recompile)))

 #+END_SRC
*** DISABLED packages
**** DISABLED exec-path-from-shell
 #+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
:config
(exec-path-from-shell-initialize))
 #+END_SRC

**** DISABLED pbcopy
 #+BEGIN_SRC emacs-lisp
(use-package pbcopy
  :ensure t)
 #+END_SRC
**** DISABLED Set-path
   #+BEGIN_SRC emacs-lisp
 (paradox-require 'exec-path-from-shell)

 (when (memq window-system '(x mac ns))
   (exec-path-from-shell-initialize))
   #+END_SRC
* Modules
** Appearance
*** config
 #+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil
                         :family "Source Code Pro"
                         :height 100
                         :weight 'normal
                         :width 'normal
                         )
     (set-face-attribute 'Info-quoted nil
                         :slant 'Italic)
     (set-face-attribute 'font-lock-string-face nil
                         :slant 'Italic)

 (defun module-fonts/spec-to-list (spec)
   (s-split "-" spec))

 (defun module-fonts/list-to-spec (spec)
   (s-join "-" spec))

 (defun module-fonts/update-font-spec-size (spec increment)
   (module-fonts/list-to-spec
    (-update-at 7 (lambda (i) (number-to-string
                               (+ (string-to-number i) increment)))
                (module-fonts/spec-to-list spec))))

 (defun module-fonts/update-font-size (increment)
   (set-frame-font
    (module-fonts/update-font-spec-size (frame-parameter nil 'font) increment)))

 (global-set-key (kbd "C-M--") (lambda () (interactive)
                                 (module-fonts/update-font-size -1)))
 (global-set-key (kbd "C-M-=") (lambda () (interactive)
                                 (module-fonts/update-font-size 1)))

 (require 'term)

 ;; Don't defer screen updates when performing operations.
 (setq redisplay-dont-pause t)

 ;; When not in a terminal, configure a few window system specific things.
 (when window-system
   (setq frame-title-format '(buffer-file-name "%f" ("%b")))
   (tooltip-mode -1)
   (mouse-wheel-mode t)
   (blink-cursor-mode -1))

 ;; Show line numbers in buffers.
 (global-linum-mode -1)
 (setq linum-format (if (not window-system) "%4d " "%4d"))

 ;; Show column numbers in modeline.
 (setq column-number-mode t)

 ;; Show current function in modeline.
 (which-function-mode)

 ;; Ensure linum-mode is disabled in certain major modes.
 (setq linum-disabled-modes
       '(term-mode slime-repl-mode magit-status-mode help-mode nrepl-mode
                   mu4e-main-mode mu4e-headers-mode mu4e-view-mode
                   mu4e-compose-mode))
 (defun linum-on ()
   (unless (or (minibufferp) (member major-mode linum-disabled-modes))
     (linum-mode 1)))

 ;; Highlight matching braces.
 (show-paren-mode 1)

 ;; Handle ANSI colours in compile buffer output.
 ;; From https://gist.github.com/jwiegley/8ae7145ba5ce64250a05
 (defun compilation-ansi-color-process-output ()
   (ansi-color-process-output nil)
   (set (make-local-variable 'comint-last-output-start)
        (point-marker)))
 (add-hook 'compilation-filter-hook #'compilation-ansi-color-process-output)

 (setq-default
   bidi-display-reordering nil         ; disable bidirectional text for tiny performance boost
   blink-matching-paren nil            ; don't blink--too distracting
   cursor-in-non-selected-windows nil  ; hide cursors in other windows
   display-line-numbers-width 3        ; minimum width used to display line numbers
   frame-inhibit-implied-resize t      ; prevent frames from automatically resizing themselves
   highlight-nonselected-windows nil   ; don't highlight selections in other windows
   fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist) fringe-indicator-alist)
   indicate-buffer-boundaries nil      ; don't indicate beginning and end of buffer in fringe
   indicate-empty-lines nil            ; don't indicate empty lines in fringe
   max-mini-window-height 0.3          ; maximum height for resizing mini windows
   mode-line-default-help-echo nil     ; disable mode-line mouseovers
   mouse-yank-at-point t               ; middle-click paste at point, not at click
   resize-mini-windows 'grow-only      ; Minibuffer resizing
   show-help-function nil              ; hide :help-echo text
   split-width-threshold 160           ; favor horizontal splits
   use-dialog-box nil                  ; always avoid GUI
   visible-cursor nil                  ; don't make cursor 'very visible'
   x-stretch-cursor nil                ; don't add wide glyph under cursor
   sentence-end-double-space nil
   mark-ring-max 64
   global-mark-ring-max 128
   save-interprogram-paste-before-kill t
   create-lockfiles nil
   echo-keystrokes 0.01
   global-hl-line-mode t


   jit-lock-defer-time nil             ; defer jit font locking slightly to [try to] improve Emacs performance
   jit-lock-stealth-nice 0.5           ; pause time between fontify chunks
   jit-lock-stealth-time 1             ; time to wait before start of stealth fontify
   jit-lock-stealth-verbose nil        ; silence stealth fontification
   ;; `pos-tip' defaults
   pos-tip-internal-border-width 6     ; increase pos-tip width
   pos-tip-border-width 1              ; define border width
   ;; no beeping or blinking please
   ring-bell-function #'ignore         ; don't beep
   visible-bell nil)                   ; don't blink

    #+END_SRC
*** packages
**** better-defaults
 #+BEGIN_SRC emacs-lisp
(use-package better-defaults)


(setq mouse-autoselect-window nil
      focus-follows-mouse nil)


 #+END_SRC
**** all-the-icons
 #+BEGIN_SRC emacs-lisp
(use-package all-the-icons)

(use-package all-the-icons-ivy
  :ensure t
  :config
  (all-the-icons-ivy-setup)
 (defun my/*disable-all-the-icons-in-tty (orig-fn &rest args)
     (when (display-graphic-p)
       (apply orig-fn args)))

(setq all-the-icons-ivy-file-commands
      '(counsel-find-file counsel-file-jump counsel-recentf counsel-projectile-find-file counsel-projectile-find-dir))

   ;; all-the-icons doesn't work in the terminal, so we "disable" it.
   (dolist (fn '(all-the-icons-octicon all-the-icons-material
                  all-the-icons-faicon all-the-icons-fileicon
                  all-the-icons-wicon all-the-icons-alltheicon))
      (advice-add fn :around #'my/*disable-all-the-icons-in-tty)))

 #+END_SRC
**** doom-modeline
 #+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :init
  (doom-modeline-mode 1))
 #+END_SRC
**** doom-themes
 #+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  :init
  (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t) ; if nil, italics is universally disabled

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)
  ;; Enable custom neotree theme (all-the-icons must be installed!)
  (doom-themes-neotree-config)
  ;; or for treemacs users
  (doom-themes-treemacs-config)
  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))

(load-theme 'doom-one)

 #+END_SRC
**** hlinum
 #+BEGIN_SRC emacs-lisp
 ;; Highlight the line number of the current line.
 (use-package hlinum
   :config
   (hlinum-activate))
 #+END_SRC
**** diminish
 #+BEGIN_SRC emacs-lisp
 ;; Unclutter the modeline
 (use-package diminish)

 (eval-after-load "eldoc" '(diminish 'eldoc-mode))
 (eval-after-load "autopair" '(diminish 'autopair-mode))
 (eval-after-load "abbrev" '(diminish 'abbrev-mode))
 (eval-after-load "js2-highlight-vars" '(diminish 'js2-highlight-vars-mode))
 (eval-after-load "mmm-mode" '(diminish 'mmm-mode))
 (eval-after-load "skewer-html" '(diminish 'skewer-html-mode))
 (eval-after-load "skewer-mode" '(diminish 'skewer-mode))
 (eval-after-load "auto-indent-mode" '(diminish 'auto-indent-minor-mode))
 (eval-after-load "cider" '(diminish 'cider-mode))
 (eval-after-load "smartparens" '(diminish 'smartparens-mode))

 #+END_SRC
** General
*** config
 #+BEGIN_SRC emacs-lisp
 (setq savehist-file (concat dotfiles-cache-dir "savehist")
       history-length 500
       savehist-save-minibuffer-history t
       savehist-autosave-interval nil ; save on kill only
       savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
       save-place-file (concat dotfiles-cache-dir "saveplace"))

(setq-default save-place t)



(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))

(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))

  (setq undo-limit (* 1024 10 10)
        undo-outer-limit (* 1024 10 10)
        undo-strong-limit (* 1024 10 10))


 (setq-default
  bookmark-default-file         (concat dotfiles-cache-dir "bookmarks")
  abbrev-file-name             (concat dotfiles-local-dir "abbrev.el")
  auto-save-list-file-name     (concat dotfiles-cache-dir "autosave")
  pcache-directory             (concat dotfiles-cache-dir "pcache"))

;; move auto-save to the cache
(let ((dir (expand-file-name (concat dotfiles-cache-dir "auto-save/"))))
  (setq auto-save-list-file-prefix (concat dir "saves-"))
  (setq auto-save-file-name-transforms `((".*" ,(concat dir "save-") t))))

(setq help-window-select t)

(setq-default
 ad-redefinition-action 'accept          ; silence advised function warnings
 apropos-do-all t                        ; make `apropos' more useful
 compilation-always-kill t               ; kill compilation process before starting another
 compilation-ask-about-save nil          ; save all buffers on `compile'
 compilation-scroll-output t             ; scroll to end of compilation output
 confirm-nonexistent-file-or-buffer t    ; confirm nonexisting files/buffers when opening
 idle-update-delay 2                     ; update ui less often (performance)
 warning-minimum-level :error            ; don't show warnings only errors
 ;; keep the point out of the minibuffer
 minibuffer-prompt-properties '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))

 (set-terminal-coding-system 'utf-8)
 (set-keyboard-coding-system 'utf-8)
 (prefer-coding-system 'utf-8)
 (load-library "iso-transl")


(setq-default
 isearch-allow-scroll t                 ; Allow scrolling in an isearch session
 lazy-highlight-cleanup nil             ; Leave highlights after an isearch session
 lazy-highlight-initial-delay 0)        ; Start highlighting immediately


(require 'vc-hooks)

;; Always follow symlinks to files under source-control. dont ask.
(setq vc-follow-symlinks t)
;; Modifications related to whitespace management

;; Disable tab indentation
(setq-default indent-tabs-mode nil)

;; Remove trailing whitespace before save.
(add-hook 'before-save-hook 'delete-trailing-whitespace)

(setq
 auto-save-default nil
 backup-inhibited t
 confirm-nonexistent-file-or-buffer nil
 create-lockfiles nil
 mouse-wheel-progressive-speed nil)


(define-key global-map [remap list-buffers] 'ibuffer)



(winner-mode +1)



(global-set-key (kbd "C-x C-c") 'save-buffers-kill-emacs)

 ;; Always ask for y/n keypress instead of typing out 'yes' or 'no'
(autoload 'ibuffer "ibuffer")

(fset 'yes-or-no-p 'y-or-n-p)


 ;; Emacs writes backup files to `filename~` by default. This is messy,
 ;; so let's tell it to write them to `~/.emacs.d/bak` instead.
 ;; If you have an accident, check this directory - you might get lucky.
(setq backup-directory-alist   ;; Save backups in $(pwd)/.bak
      '(("." . ".bak"))        ;;
      )

(setq version-control t
      backup-by-copying t      ;; Copy-on-write-esque
      kept-new-versions 64     ;; Indeliable-ink-esque
      kept-old-versions 0      ;;
      delete-old-versions t    ;;
      )



 ;; Automatically save buffers before launching M-x compile and friends,
 ;; instead of asking you if you want to save.
 (setq compilation-ask-about-save nil)

 ;; Make the selection work like most people expect.
 (delete-selection-mode 1)
 (transient-mark-mode t)

(global-set-key (kbd "DEL") 'backward-delete-char)

;; Enable `downcase-region' and `upcase-region'
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)


 ;; Automatically update unmodified buffers whose files have changed.
 (global-auto-revert-mode 1)

 ;; If available, use `xdg-open' to open URLs.
 (when (core/is-exec "xdg-open")
   (setq-default
    browse-url-browser-function (quote browse-url-generic)
    browse-url-generic-program "xdg-open"))

 ;; Make compilation buffers scroll to follow the output, but stop scrolling
 ;; at the first error.
 (setq compilation-scroll-output 'first-error)

(setq-default uniquify-buffer-name-style 'forward)


(global-unset-key [(control z)])
(global-unset-key [(control x)(control z)])
(global-unset-key (kbd "<f1>"))
(global-unset-key (kbd "<f2>"))
(global-unset-key (kbd "<f3>"))
(global-unset-key (kbd "<f4>"))
(global-unset-key (kbd "<f5>"))
(global-unset-key (kbd "<f6>"))
(global-unset-key (kbd "<f7>"))
(global-unset-key (kbd "<f8>"))
(global-unset-key (kbd "<f9>"))
(global-unset-key (kbd "<f10>"))
(global-unset-key (kbd "<f11>"))
(global-unset-key (kbd "<f12>"))

(dotimes (n 10)
  (global-unset-key (kbd (format "C-%d" n)))
  (global-unset-key (kbd (format "M-%d" n)))
  )

  #+END_SRC
*** packages
**** recentf
 #+BEGIN_SRC emacs-lisp
(use-package recentf
  :demand t
  :config
  (setq recentf-save-file (concat dotfiles-etc-dir "recentf")
      recentf-max-menu-items 0
      recentf-max-saved-items 300)
  (recentf-mode))

 #+END_SRC

**** vlf
 #+BEGIN_SRC emacs-lisp
(use-package vlf)
 #+END_SRC
**** scratch
   #+BEGIN_SRC emacs-lisp
(use-package scratch)
   #+END_SRC
**** persistent-scratch
 #+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
:init
(persistent-scratch-setup-default))
 #+END_SRC
**** unkillable-scratch
   #+BEGIN_SRC emacs-lisp
(use-package unkillable-scratch
  :ensure t
  :config
  (unkillable-scratch t)
  (setq unkillable-scratch-do-not-reset-scratch-buffer t))
   #+END_SRC

**** desktop-environment
  #+BEGIN_SRC emacs-lisp
(use-package desktop-environment
:init
(desktop-environment-mode +1))
  #+END_SRC

**** visual-fill-column
 #+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
   :commands visual-fill-column-mode
   :config
   (setq-default
     visual-fill-column-center-text t
     visual-fill-column-width
     ;; take Emacs 26 line numbers into account
     (+ (if (boundp 'display-line-numbers) 6 0)
        fill-column)))
 #+END_SRC
**** company
   #+BEGIN_SRC emacs-lisp
   (use-package company
     :demand t
     :commands company-mode
     :config
     ;; Enable company-mode globally.
     (global-company-mode)
     ;; Except when you're in term-mode.
     (setq company-global-modes '(not term-mode))
     ;; Give Company a decent default configuration.
     (setq company-minimum-prefix-length 2
           company-selection-wrap-around t
           company-show-numbers t
           company-tooltip-align-annotations t
           company-require-match nil
           company-dabbrev-downcase nil
           company-dabbrev-ignore-case nil)
     ;; Sort completion candidates that already occur in the current
     ;; buffer at the top of the candidate list.
     (setq company-transformers '(company-sort-by-occurrence))
     ;; Show documentation where available for selected completion
     ;; after a short delay.
     (use-package company-quickhelp
       :config
       (setq company-quickhelp-delay 1)
       (company-quickhelp-mode 1))
     ;; Add a completion source for emoji. ðŸ˜¸
     (use-package company-emoji
       :config
       (company-emoji-init))

     ;; Use C-\ to activate the Company autocompleter.
     ;; We invoke company-try-hard to gather completion candidates from multiple
     ;; sources if the active source isn't being very forthcoming.
     (use-package company-try-hard
       :commands company-try-hard)

   )
   #+END_SRC

**** ivy
  #+BEGIN_SRC emacs-lisp
(use-package ivy
   :config
  (setq ivy-height 15                                  ; slightly longer ivy completions list
        ivy-wrap t                                     ; wrap around at end of completions list
        ivy-fixed-height-minibuffer t                  ; use consistent height for ivy
        projectile-completion-system 'ivy              ; use ivy for projectile
        smex-completion-method 'ivy                    ; use ivy for smex
        ivy-initial-inputs-alist nil                   ; don't use ^ as initial input
        ivy-format-function #'ivy-format-function-line ; highlight til EOL
        ivy-use-virtual-buffers nil                    ; dont' show recent files in switch-buffer
        ivy-virtual-abbreviate 'full                   ; show full path if showing virtual buffer
        ivy-magic-slash-non-match-action nil           ; disable magic slash on non-match
        ivy-on-del-error-function nil                  ; don't quit minibuffer on delete-error
        ivy-use-selectable-prompt t)                   ; allow input prompt value to be selectable

  (after! magit     (setq magit-completing-read-function #'ivy-completing-read))
  (after! yasnippet (add-to-list 'yas-prompt-functions #'+ivy-yas-prompt nil #'eq))

)


(use-package counsel
  :hook
  (after-init . ivy-mode)
  :diminish ivy-mode
  :bind
  (("C-c C-r" . ivy-resume)
   ("M-x" . counsel-M-x)
   ("<execute>" . counsel-M-x)
   ("C-c i" . counsel-imenu)
   ("C-x b" . counsel-switch-buffer)
   ("C-x B" . counsel-switch-buffer-other-window)
   ("C-x k" . kill-buffer)
   ("C-x C-f" . counsel-find-file)
   ("C-x l" . counsel-locate)
   ("C-c j" . counsel-git)
   :map help-map
   ("f" . counsel-describe-function)
   ("v" . counsel-describe-variable)
   ("l" . counsel-info-lookup-symbol)
   :map ivy-minibuffer-map
   ("C-o" . ivy-occur)
   ("<return>" . ivy-alt-done)
   ("M-<return>" . ivy-immediate-done)
   :map read-expression-map
   ("C-r" . counsel-minibuffer-history))
  :custom
  (counsel-find-file-at-point t)
  (ivy-use-virtual-buffers nil)
  (ivy-display-style 'fancy)
  (ivy-use-selectable-prompt t)
  (ivy-re-builders-alist
   '((ivy-switch-buffer . ivy--regex-plus)
     (swiper . ivy--regex-plus)
     (t . ivy--regex-fuzzy)))
  :config
(defun my/counsel-switch-buffer-other-window ()
(interactive)
(ace-window nil)
(counsel-switch-buffer))
  (ivy-set-actions
   t
   '(("I" insert "insert")))
  (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))

(use-package swiper
  :bind
  (("C-s" . swiper)
   ("C-r" . counsel-grep-or-swiper)
   :map swiper-map
   ("M-q" . swiper-query-replace)
   ("C-l". swiper-recenter-top-bottom))
  :custom
  (counsel-grep-swiper-limit 20000)
  (counsel-rg-base-command
   "rg -i -M 120 --no-heading --line-number --color never %s .")
  (counsel-grep-base-command
   "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))

(use-package wgrep
  :commands
  wgrep-change-to-wgrep-mode
  ivy-wgrep-change-to-wgrep-mode)

(use-package deadgrep
  :bind* (("M-s" . deadgrep)))


(use-package historian
  :init
  (require 'el-patch)

  (autoload #'historian--nadvice/completing-read "historian")
  (setq historian-save-file (concat user-emacs-directory ".historian"))

  (el-patch-feature historian)

  (el-patch-defun historian-load ()
    (interactive)
    (setq historian--history-table
          (if (file-exists-p historian-save-file)
              (with-temp-buffer
                (insert-file-contents historian-save-file)
                (read (current-buffer)))
            (make-hash-table))))

  (el-patch-define-minor-mode historian-mode
    "historian minor mode"
    :init-value nil
    :group 'historian
    :global t
    (if historian-mode
        (progn
          (historian-load)
          (advice-add 'completing-read :filter-return
                      #'historian--nadvice/completing-read)
          (add-hook 'kill-emacs-hook #'historian-save))

      (historian-save)
      (advice-remove 'completing-read #'historian--nadvice/completing-read)
      (remove-hook 'kill-emacs-hook #'historian-save))))

(use-package ivy-historian)

(use-package smex
  :config
(setq smex-save-file (concat dotfiles-cache-dir "/smex-items"))
(smex-initialize))

(use-package ivy-rich
  :demand t
  :after ivy)

(defun +ivy-buffer-transformer (str)
  "Dim special buffers, buffers whose file aren't in the current buffer, and
virtual buffers. Uses `ivy-rich' under the hood."
  (let ((buf (get-buffer str)))
    (require 'ivy-rich)
    (cond (buf (ivy-rich-switch-buffer-transformer str))
          ((and (eq ivy-virtual-abbreviate 'full)
                ivy-rich-switch-buffer-align-virtual-buffer)
           (ivy-rich-switch-buffer-virtual-buffer str))
          ((eq ivy-virtual-abbreviate 'full)
           (propertize (abbreviate-file-name str) 'str 'ivy-virtual))
          (t (propertize str 'face 'ivy-virtual)))))

(defun +ivy*rich-switch-buffer-buffer-name (str)
  (propertize
   (ivy-rich-pad str ivy-rich-switch-buffer-name-max-length)
   'face (cond ((string-match-p "^ *\\*" str)
                'font-lock-comment-face)
               ((and buffer-file-truename
                     (not (file-in-directory-p buffer-file-truename (my/project-root))))
                'font-lock-doc-face)
               (t nil))))
(advice-add 'ivy-rich-switch-buffer-buffer-name :override #'+ivy*rich-switch-buffer-buffer-name)




(ivy-mode +1)
(historian-mode +1)
(ivy-historian-mode +1)


(defun +ivy/wgrep-occur ()
  "Invoke the search+replace wgrep buffer on the current ag/rg search results."
  (interactive)
  (unless (window-minibuffer-p)
    (user-error "No completion session is active"))
  (require 'wgrep)
  (let* ((caller (ivy-state-caller ivy-last))
         (occur-fn (plist-get ivy--occurs-list caller))
         (buffer
          (generate-new-buffer
           (format "*ivy-occur%s \"%s\"*"
                   (if caller (concat " " (prin1-to-string caller)) "")
                   ivy-text))))
    (with-current-buffer buffer
      (let ((inhibit-read-only t))
        (erase-buffer)
        (funcall occur-fn))
      (setf (ivy-state-text ivy-last) ivy-text)
      (setq ivy-occur-last ivy-last)
      (setq-local ivy--directory ivy--directory))
    (ivy-exit-with-action
     `(lambda (_)
        (pop-to-buffer ,buffer)
        (ivy-wgrep-change-to-wgrep-mode)))))

(defun +ivy--tasks-candidates (tasks)
  "Generate a list of task tags (specified by `+ivy-task-tags') for
`+ivy/tasks'."
  (let* ((max-type-width
          (cl-loop for task in +ivy-task-tags maximize (length (car task))))
         (max-desc-width
          (cl-loop for task in tasks maximize (length (cl-cdadr task))))
         (max-width (max (- (frame-width) (1+ max-type-width) max-desc-width)
                         25)))
    (cl-loop
     with fmt = (format "%%-%ds %%-%ds%%s%%s:%%s" max-type-width max-width)
     for alist in tasks
     collect
     (let-alist alist
       (format fmt
               (propertize .type 'face (cdr (assoc .type +ivy-task-tags)))
               (substring .desc 0 (min max-desc-width (length .desc)))
               (propertize " | " 'face 'font-lock-comment-face)
               (propertize (abbreviate-file-name .file) 'face 'font-lock-keyword-face)
               (propertize .line 'face 'font-lock-constant-face))))))

(defun +ivy--tasks (target)
  (let* (case-fold-search
         (task-tags (mapcar #'car +ivy-task-tags))
         (cmd
          (format "%s -H -S --no-heading -- %s %s"
                  (or (when-let* ((bin (executable-find "rg")))
                        (concat bin " --line-number"))
                      (when-let* ((bin (executable-find "ag")))
                        (concat bin " --numbers"))
                      (error "ripgrep & the_silver_searcher are unavailable"))
                  (shell-quote-argument
                   (concat "\\s("
                           (string-join task-tags "|")
                           ")([\\s:]|\\([^)]+\\):?)"))
                  target)))
    (save-match-data
      (cl-loop with out = (shell-command-to-string cmd)
               for x in (and out (split-string out "\n" t))
               when (condition-case-unless-debug ex
                      (string-match
                       (concat "^\\([^:]+\\):\\([0-9]+\\):.+\\("
                               (string-join task-tags "\\|")
                               "\\):?\\s-*\\(.+\\)")
                       x)
                      (error
                       (print! (red "Error matching task in file: (%s) %s"
                                    (error-message-string ex)
                                    (car (split-string x ":"))))
                       nil))
               collect `((type . ,(match-string 3 x))
                         (desc . ,(match-string 4 x))
                         (file . ,(match-string 1 x))
                         (line . ,(match-string 2 x)))))))

(defun +ivy--tasks-open-action (x)
  "Jump to the file and line of the current task."
  (let ((location (cadr (split-string x " | ")))
        (type (car (split-string x " "))))
    (cl-destructuring-bind (file line) (split-string location ":")
      (with-ivy-window
        (find-file (expand-file-name file (doom-project-root)))
        (goto-char (point-min))
        (forward-line (1- (string-to-number line)))
        (search-forward type (line-end-position) t)
        (backward-char (length type))
        (recenter)))))

(defun +ivy/tasks (&optional arg)
  "Search through all TODO/FIXME tags in the current project. If ARG, only
search current file. See `+ivy-task-tags' to customize what this searches for."
  (interactive "P")
  (ivy-read (format "Tasks (%s): "
                    (if arg
                        (concat "in: " (file-relative-name buffer-file-name))
                      "project"))
            (+ivy--tasks-candidates
             (+ivy--tasks (if arg buffer-file-name (doom-project-root))))
            :action #'+ivy--tasks-open-action
            :caller '+ivy/tasks))

(defun +ivy-git-grep-other-window-action (x)
  "Opens the current candidate in another window."
  (when (string-match "\\`\\(.*?\\):\\([0-9]+\\):\\(.*\\)\\'" x)
    (select-window
     (with-ivy-window
       (let ((file-name   (match-string-no-properties 1 x))
             (line-number (match-string-no-properties 2 x)))
         (find-file-other-window (expand-file-name file-name (ivy-state-directory ivy-last)))
         (goto-char (point-min))
         (forward-line (1- (string-to-number line-number)))
         (re-search-forward (ivy--regex ivy-text t) (line-end-position) t)
         (run-hooks 'counsel-grep-post-action-hook)
         (selected-window))))))


(provide 'module-ivy)
  #+END_SRC
**** yasnippets
   #+BEGIN_SRC emacs-lisp
 (use-package yasnippet
   ;;:commands yas-global-mode
   :config
   (yas-global-mode 1))

(use-package yasnippet-snippets
:config
(require 'yasnippet-snippets))

(use-package auto-yasnippet
:config
(require 'auto-yasnippet))
   #+END_SRC
**** Git
   #+BEGIN_SRC emacs-lisp
 (use-package magit
   :commands magit-status
   :bind ("C-x g" . magit-status))


 (use-package gist)
 (use-package git-timemachine)


   #+END_SRC
**** el-patch
   #+BEGIN_SRC emacs-lisp
(use-package el-patch)
   #+END_SRC
**** Dashboard
   #+BEGIN_SRC emacs-lisp
 (use-package dashboard
   :init
   ;(dashboard-setup-startup-hook)
   :config
   (setq dashboard-center-content t)
   (setq dashboard-startup-banner ()  )
 ;  (add-to-list 'dashboard-items '(agenda) t)
   (setq dashboard-items '())

 (add-to-list 'dashboard-item-generators  '(custom . dashboard-insert-custom))
 (add-to-list 'dashboard-items '(custom) t)

     (defvar all-the-icons-scale-factor)
 (defvar all-the-icons-default-adjust)
 (defun dashboard-insert-custom (list-size)
   (let ((all-the-icons-scale-factor 2.00)
         (all-the-icons-default-adjust -0.00))
     (mapc (lambda (btn)
             (when btn
               (cl-destructuring-bind (label icon fn) btn
                 (insert
                  (with-temp-buffer
                    (insert-text-button
                     (concat (all-the-icons-octicon icon :face 'font-lock-keyword-face)
                             (propertize (concat " " label) 'face 'font-lock-keyword-face))
                     'action `(lambda (_) ,fn)
                     'follow-link t)
                    (dashboard-center (- dashboard--width 2) (buffer-string)))
                  "\n\n"))))
           `( ("Open project" "briefcase"
              (call-interactively (or (command-remapping #'projectile-switch-project)
                                      #'projectile-switch-project)))

              ("Bookmarks" "bookmark"
              (call-interactively (or (command-remapping #'bookmark-jump)
                                      #'bookmark-jump)))

              ,(when (fboundp 'org-agenda-list)
              '("Agenda for this week" "calendar"
                (call-interactively #'org-agenda-list)))


              ("Capture" "comment"
               (call-interactively (or (command-remapping #'org-capture)
                                       #'org-capture)))
           ))))


 (defvar dashboard--width 80)
 (defvar dashboard--height 0)
 (defvar dashboard--old-fringe-indicator fringe-indicator-alist)
 (defun dashboard-center (len s)
   (concat (make-string (ceiling (max 0 (- len (length s))) 2) ? )
           s))


 (defun avy-dashboard-button (char &optional arg)
     "Jump to the currently visible CHAR.
   The window scope is determined by `avy-all-windows' (ARG negates it)."
     (interactive (list (read-char "char: " t)
                        current-prefix-arg))

     (avy-with avy-goto-char
       (avy-jump
        (if (= 13 char)
            "\n"
          (regexp-quote (string char)))
        :window-flip arg))
     (push-button arg))

 (define-key dashboard-mode-map "n" #'dashboard/next-button)
 (define-key dashboard-mode-map "p" #'dashboard/previous-button)

 (define-key dashboard-mode-map [right] #'dashboard/next-button)
 (define-key dashboard-mode-map [left] #'dashboard/previous-button)
 (define-key dashboard-mode-map [down] #'dashboard/next-button)
 (define-key dashboard-mode-map [up] #'dashboard/previous-button)


 (define-key dashboard-mode-map "s" #'org-save-all-org-buffers)
 (define-key dashboard-mode-map [tab] #'avy-dashboard-button)


 (define-derived-mode dashboard-mode special-mode
   (format "Dashboard")
   "Major mode for the BMACS dashboard buffer."
   (read-only-mode +1)
   (global-linum-mode -1)
   (page-break-lines-mode +1)
   (setq truncate-lines t)
   (setq whitespace-style nil)
   (setq global-whitespace-mode nil)
   (setq whitespace-mode nil)
   (setq electric-indent-mode -1)
   (setq show-trailing-whitespace nil)

   (cl-loop for (car . _cdr) in fringe-indicator-alist
            collect (cons car nil) into alist
            finally do (setq fringe-indicator-alist alist)))

 (defun dashboard/next-button ()
   (interactive)
   (ignore-errors (goto-char (next-button (point)))))
 (defun dashboard/previous-button ()
   (interactive)
   (ignore-errors (goto-char (previous-button (point))))))

   #+END_SRC

** Navigation
*** config
 #+BEGIN_SRC emacs-lisp
(setq scroll-error-top-bottom t)

(defun smart-beginning-of-line ()
  "Move point to first non-whitespace character or beginning-of-line."
  (interactive "^")
  (let ((oldpos (point)))
    (back-to-indentation)
    (and (= oldpos (point))
         (beginning-of-line))))
(global-set-key (kbd "<home>") 'smart-beginning-of-line)
(global-set-key (kbd "C-a") 'smart-beginning-of-line)

;; Consider CamelCase chunks as words when navigating.
(global-subword-mode 1)

;; Use C-x M-p to kill the buffer in the other window, revealing
;; the next buffer in the stack.
(global-set-key
 (kbd "C-x M-p")
 (lambda () (interactive)
   (save-excursion
     (other-window 1)
     (quit-window))))
 #+END_SRC
*** packages
**** avy
 #+BEGIN_SRC emacs-lisp
(use-package avy
  :demand t
  :bind (("C-;" . avy-goto-word-1)
         ("C-:" . avy-goto-char))
  :config
  (with-eval-after-load "isearch"
    (define-key isearch-mode-map (kbd "C-;") 'avy-isearch)))
 #+END_SRC
**** anzu
 #+BEGIN_SRC emacs-lisp
(use-package anzu
  :demand t
  :config
  (global-anzu-mode 1)
  ;; Anzu provides a version of `query-replace' and friends which give visual
  ;; feedback when composing regexps. Let's replace the regular versions.
  :bind(("C-%" . anzu-query-replace-at-cursor)
        ("M-%" . anzu-query-replace)
        ("C-M-%" . anzu-query-replace-regexp))
  :diminish anzu-mode)
 #+END_SRC
**** ace-window
   #+BEGIN_SRC emacs-lisp :tangle
(use-package ace-window
  :config
  (setq aw-scope 'frame))

 (defun module/previous-window ()
   (interactive)
   (-let [current (selected-window)]
     (cond
      ((eq module/--last-window current)
       (ace-select-window))

      ((window-live-p module/--last-window)
       (select-window module/--last-window))

      (t
       (ace-select-window)))
     (setq module/--last-window current)))

 (defun module/select-window ()
   (interactive)
   (setq module/--last-window (selected-window))
   (ace-select-window))

 (setq module/--last-window (selected-window))

 (global-set-key (kbd "C-x o") 'module/previous-window)
 (global-set-key (kbd "C-x C-o") 'module/select-window)
 (global-set-key (kbd "C-x \\") 'ace-swap-window)


   #+END_SRC
**** windmove
 #+BEGIN_SRC emacs-lisp
(use-package windmove)
 #+END_SRC

**** buffer-move
#+BEGIN_SRC emacs-lisp
(use-package buffer-move)
#+END_SRC

**** transpose-frame
#+BEGIN_SRC emacs-lisp
(use-package transpose-frame)
#+END_SRC

**** beacon
 #+BEGIN_SRC emacs-lisp
(use-package beacon
   :init
   (beacon-mode 1))
 #+END_SRC
**** dired-k
   #+BEGIN_SRC emacs-lisp
 (setq global-auto-revert-non-file-buffers t)
 (setq auto-revert-verbose nil)

 (setq ;; Always copy/delete recursively
       dired-recursive-copies  'always
       dired-recursive-deletes 'top
       ;; files
       image-dired-dir (concat user-emacs-directory "image-dired/")
       image-dired-db-file (concat user-emacs-directory "image-dired/db.el")
       image-dired-gallery-dir (concat user-emacs-directory "gallery/")
       image-dired-temp-image-file (concat user-emacs-directory "temp-image")
       image-dired-temp-rotate-image-file (concat user-emacs-directory "temp-rotate-image"))


 (use-package dired-k
   :after dired
   :config
   (setq dired-k-style 'git)

   (defun +dired*dired-k-highlight (orig-fn &rest args)
     "Butt out if the requested directory is remote (i.e. through tramp)."
     (unless (file-remote-p default-directory)
       (apply orig-fn args)))
   (advice-add #'dired-k--highlight :around #'+dired*dired-k-highlight)

   (add-hook 'dired-initial-position-hook #'dired-k)
   (add-hook 'dired-after-readin-hook #'dired-k-no-revert))


 ;; A function for deleting the file being edited.
 ;; This one is a bit dangerous, even with the yes/no question, so
 ;; it's not bound to any key by default.
 ;; Run it using M-x delete-current-buffer-file.
 (defun delete-current-buffer-file ()
   "Removes file connected to current buffer and kills buffer."
   (interactive)
   (let ((filename (buffer-file-name))
         (buffer (current-buffer))
         (name (buffer-name)))
     (if (not (and filename (file-exists-p filename)))
         (ido-kill-buffer)
       (when (yes-or-no-p "Are you sure you want to remove this file? ")
         (delete-file filename)
         (kill-buffer buffer)
         (message "File '%s' successfully removed" filename)))))

 ;; And a function for renaming the file being edited, bound to C-x C-r.
 (defun rename-current-buffer-file ()
   "Renames current buffer and file it is visiting."
   (interactive)
   (let ((name (buffer-name))
         (filename (buffer-file-name)))
     (if (not (and filename (file-exists-p filename)))
         (error "Buffer '%s' is not visiting a file!" name)
       (let ((new-name (read-file-name "New name: " filename)))
         (if (get-buffer new-name)
             (error "A buffer named '%s' already exists!" new-name)
           (rename-file filename new-name 1)
           (rename-buffer new-name)
           (set-visited-file-name new-name)
           (set-buffer-modified-p nil)
           (message "File '%s' successfully renamed to '%s'"
                    name (file-name-nondirectory new-name)))))))
 (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

(require 'dired)

(setq wdired-use-dired-vertical-movement 'sometimes)
(define-key dired-mode-map (kbd "C-s") #'dired-isearch-filenames)

    #+END_SRC
**** stripe-buffer
#+BEGIN_SRC emacs-lisp
(use-package stripe-buffer
   :commands stripe-buffer-mode
   :init (add-hook 'dired-mode-hook #'stripe-buffer-mode))

#+END_SRC
** Editing
*** config
 #+BEGIN_SRC emacs-lisp :tangle
(setq bookmark-save-flag 1) ;; save after every change

(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
      select-enable-clipboard t
      select-enable-primary t)

(setq-default
 fill-column 100                  ; set line-wrapping column to 100
 word-wrap t                     ; enable word wrap so lines are wrapped at nearest space
 ;; TODO: Investigate these further
 truncate-lines t
 truncate-partial-width-windows 50)

(setq-default
 indent-tabs-mode nil         ; don't insert tabs by default
 require-final-newline t      ; ensure newline exists at end of file
 tab-always-indent t          ; always indent line when pressing TAB (don't add tab character)
 tab-width 2                  ; default tab width of 2 characters
 tabify-regexp "^\t* [ \t]+") ; only tabify initial whitespace when converting to tabifying

(setq-default
 vc-follow-symlinks t                             ; automatically follow symlinks
 save-interprogram-paste-before-kill t)           ; save clipboard contents into kill-ring before replacing them
(global-auto-revert-mode t)                       ; revert changed buffers
(show-paren-mode)                                 ; highlight matching parenthesis
(push '("/LICENSE$" . text-mode) auto-mode-alist) ; license files should be handled in text mode

 ;; whitespace-mode
(setq-default
 whitespace-line-column fill-column
 whitespace-style
 '(face indentation tabs tab-mark spaces space-mark newline newline-mark trailing lines-tail)
 whitespace-display-mappings
 '((tab-mark ?\t [?â€º ?\t])
   (newline-mark ?\n [?Â¬ ?\n])
   (space-mark ?\  [?Â·] [?.])))

(setq-default
 scroll-conservatively 1001             ; always scroll to the point no matter how far away (don't recenter)
 scroll-margin 3                        ; don't automatically scroll to retain a margin
 scroll-preserve-screen-position t)     ; preserve point location on screen when scrolling

 (setq require-final-newline t)

 (setq echo-keystrokes 0.001)

 (setq-default indent-tabs-mode nil)   ;; don't use tabs to indent
 (setq-default tab-width 8)            ;; but maintain correct appearance


 (require 'super-save)
 ;; add integration with ace-window
 (add-to-list 'super-save-triggers 'ace-window)
 (super-save-mode +1)


 (setq tab-always-indent 'complete)

 (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                          try-expand-dabbrev-all-buffers
                                          try-expand-dabbrev-from-kill
                                          try-complete-file-name-partially
                                          try-complete-file-name
                                          try-expand-all-abbrevs
                                          try-expand-list
                                          try-expand-line
                                          try-complete-lisp-symbol-partially
                                          try-complete-lisp-symbol))



 (global-auto-revert-mode t)

 (windmove-default-keybindings)

 (require 'tramp)
 ;; keep in mind known issues with zsh - see emacs wiki
 (setq tramp-default-method "ssh")

 (require 'flyspell)
 (setq ispell-program-name "aspell" ; use aspell instead of ispell
       ispell-extra-args '("--sug-mode=ultra"))

 (flyspell-mode t)

 ;; enable narrowing commands
 (put 'narrow-to-region 'disabled nil)
 (put 'narrow-to-page 'disabled nil)
 (put 'narrow-to-defun 'disabled nil)

 ;; enabled change region case commands
 (put 'upcase-region 'disabled nil)
 (put 'downcase-region 'disabled nil)

 ;; enable erase-buffer command
 (put 'erase-buffer 'disabled nil)


 ;; Remap join-line to M-j where it's easier to get to.
 ;; join-line will join the line you're on with the line above it
 ;; in a reasonable manner for the type of file you're editing.
 (global-set-key (kbd "M-j") 'join-line)

 ;; Hit C-c <tab> to auto-indent the entire buffer you're in.
 (defun indent-buffer ()
   (interactive)
   (indent-region (point-min) (point-max)))
 (global-set-key (kbd "C-c <tab>") 'indent-buffer)

 ;; Automatically insert matching braces and do other clever
 ;; things pertaining to braces and such.

 ;; Duplicate start of line or region with C-M-<end>.
 ;; From http://www.emacswiki.org/emacs/DuplicateStartOfLineOrRegion
 (defun duplicate-start-of-line-or-region ()
   (interactive)
   (if mark-active
       (duplicate-region)
     (duplicate-start-of-line)))
 (defun duplicate-start-of-line ()
   (if (bolp)
       (progn
         (end-of-line)
         (duplicate-start-of-line)
         (beginning-of-line))
     (let ((text (buffer-substring (point)
                                   (beginning-of-thing 'line))))
       (forward-line)
       (push-mark)
       (insert text)
       (open-line 1))))
 (defun duplicate-region ()
   (let* ((end (region-end))
          (text (buffer-substring (region-beginning) end)))
     (goto-char end)
     (insert text)
     (push-mark end)
     (setq deactivate-mark nil)
     (exchange-point-and-mark)))
 (global-set-key (kbd "C-M-<end>") 'duplicate-start-of-line-or-region)


;; Causes entire elements (with children) to be treated as sexps.
(setq nxml-sexp-element-flag t)
;; prog-mode should have auto-completion by default.

 #+END_SRC
*** packages
**** elmacro
  #+BEGIN_SRC emacs-lisp
 (use-package elmacro)
  #+END_SRC
**** avy
 #+BEGIN_SRC emacs-lisp
(use-package avy
   :config
   (setq avy-background t)
   (setq avy-style 'at-full))
 #+END_SRC
**** browse-kill-ring
 #+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring)
 (require 'browse-kill-ring)
 (browse-kill-ring-default-keybindings)
 (global-set-key (kbd "s-y") 'browse-kill-ring)
 #+END_SRC
**** super-save
 #+BEGIN_SRC emacs-lisp
(use-package super-save)
 #+END_SRC
**** editorconfig
  #+BEGIN_SRC emacs-lisp
(use-package editorconfig)
  #+END_SRC
**** expand-region
 #+BEGIN_SRC emacs-lisp
(use-package expand-region
   :commands er/expand-region)
 #+END_SRC
**** Org-mode
***** org
     #+BEGIN_SRC emacs-lisp
 (use-package org
   :ensure org-plus-contrib
   :config
   ;; Stop org-mode from highjacking shift-cursor keys.
   (setq org-replace-disputed-keys t)
   ;; Always use visual-line-mode in org-mode, and wrap it at column 80.
   (add-hook
    'org-mode-hook
    (lambda ()
      (visual-line-mode 1))))
      #+END_SRC
***** org-cliplink
#+BEGIN_SRC emacs-lisp
(use-package org-cliplink)
#+END_SRC
***** org-download
#+BEGIN_SRC emacs-lisp
 (use-package org-download
 :init
 (setq org-download-method 'attach)
 (setq org-image-actual-width 600))

#+END_SRC
***** org-journal
#+BEGIN_SRC emacs-lisp
(use-package org-journal
   :init
   (setq org-journal-file-format "%Y-%m-%d.org"))
#+END_SRC
***** org-noter
#+BEGIN_SRC emacs-lisp
 (use-package org-noter)
#+END_SRC
***** org-pomodoro
#+BEGIN_SRC emacs-lisp
 (use-package org-pomodoro)
#+END_SRC
***** org-web-tools
#+BEGIN_SRC emacs-lisp
 (use-package org-web-tools
 :init
 (setq org-web-tools-attach-archive-retry 15))

#+END_SRC
***** org-brain
#+BEGIN_SRC emacs-lisp
 (use-package org-brain
   :config
   (setq org-id-track-globally t)
   (setq org-id-locations-file "~/.emacs.d/.org-id-locations")
   (setq org-brain-visualize-default-choices 'all)
   (setq org-brain-title-max-length 12))

#+END_SRC
**** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
   :config
 (global-set-key (kbd "M-n") 'next-error)
 (global-set-key (kbd "M-p") 'previous-error)
   ;; Start it automatically for all modes except ELisp mode,
   (add-hook 'find-file-hook
             (lambda ()
               (when (not (equal 'emacs-lisp-mode major-mode))
                 (flycheck-mode)))))

#+END_SRC
***** flycheck-color-mode-line
#+BEGIN_SRC emacs-lisp
(use-package flycheck-color-mode-line
   :config
   (with-eval-after-load "flycheck"
     (setq flycheck-highlighting-mode 'symbols)
     (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
#+END_SRC
**** Markdown
   #+BEGIN_SRC emacs-lisp
 ;; Install Markdown support.
 (use-package markdown-mode
   :commands markdown-mode
   :mode (("\\.markdown$" . markdown-mode)
          ("\\.md$" . markdown-mode))
   :config
   (add-hook 'markdown-mode-hook 'visual-line-mode))
   #+END_SRC
***** ox-gfm
#+BEGIN_SRC emacs-lisp
(use-package ox-gfm)
#+END_SRC
**** smartparens
  #+BEGIN_SRC emacs-lisp
(use-package smartparens)
  #+END_SRC

** Help
*** packages
**** which-key
   #+BEGIN_SRC emacs-lisp
(use-package which-key
  :demand t
  :bind ("C-h C-k" . which-key-show-top-level)
  :config
  (setq which-key-sort-order #'which-key-prefix-then-key-order
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-idle-delay 0.0
        which-key-special-keys nil
        which-key-min-display-lines 7)
  (set-face-attribute 'which-key-local-map-description-face nil :weight 'bold)
  (which-key-setup-side-window-bottom)
  (which-key-mode)
  :diminish which-key-mode)
   #+END_SRC
**** discover-my-major
 #+BEGIN_SRC emacs-lisp
(use-package discover-my-major
  :commands (discover-my-major discover-my-mode)
  :bind ("<f1>" . discover-my-major))
 #+END_SRC
**** hydra
 #+BEGIN_SRC emacs-lisp
(use-package hydra)
 #+END_SRC
