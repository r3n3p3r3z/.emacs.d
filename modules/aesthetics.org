#+TITLE: aesthetics and sane defaults
#+AUTHOR: Alexander Soto


Eyebrowse is a great package for workspaces in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t
  :init
  (defun eos/create-eyebrowse-setup ()
    (interactive)
    "Create a default window config, if none is present"
    (when (not (eyebrowse--window-config-present-p 4))
      ;; there's probably a better way to do this, creating four workspaces
      (eyebrowse-switch-to-window-config-2)
      (eyebrowse-switch-to-window-config-3)
      (eyebrowse-switch-to-window-config-4)
      (eyebrowse-switch-to-window-config-1)))
  (setq eyebrowse-wrap-around t
        eyebrowse-new-workspace t
        eyebrowse-mode-line-separator " ")
  (eyebrowse-mode 1)
  (global-set-key (kbd "C-'") 'eyebrowse-next-window-config)
  (global-set-key (kbd "C-\"") 'eyebrowse-prev-window-config)
  (add-hook 'after-init-hook #'eos/create-eyebrowse-setup))


  (defvar window-snapshots '())

  (defun save-window-snapshot ()
    "Save the current window configuration into `window-snapshots` alist."
    (interactive)
    (let ((key (read-string "Enter a name for the snapshot: ")))
      (setf (alist-get key window-snapshots) (current-window-configuration))
      (message "%s window snapshot saved!" key)))

  (defun get-window-snapshot (key)
    "Given a KEY return the saved value in `window-snapshots` alist."
    (let ((value (assoc key window-snapshots)))
      (cdr value)))

  (defun restore-window-snapshot ()
    "Restore a window snapshot from the window-snapshots alist."
    (interactive)
    (let* ((snapshot-name (completing-read "Choose snapshot: " (mapcar #'car window-snapshots)))
           (snapshot (get-window-snapshot snapshot-name)))
      (if snapshot
          (set-window-configuration snapshot)
        (message "Snapshot %s not found" snapshot-name))))





#+END_SRC



#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-lFaGh1v --group-directories-first")

(defhydra eos/hydra-about-emacs ()
  "
    About Emacs                                                        [_q_] quit
    ^^--------------------------------------------------------------------------
    PID:             %s(emacs-pid)
    Uptime:          %s(emacs-uptime)
    Init time:       %s(emacs-init-time)
    Directory:       %s(identity user-emacs-directory)
    Invoked from:    %s(concat invocation-directory invocation-name)
    Version:         %s(identity emacs-version)

    User Info
    ^^--------------------------------------------------------------------------
    User name:       %s(user-full-name)
    Login (real):    %s(user-login-name) (%s(user-real-login-name))
      UID (real):    %s(user-uid) (%s(user-real-uid))
      GID (real):    %s(group-gid) (%s(group-real-gid))
    Mail address:    %s(identity user-mail-address)

    System Info
    ^^--------------------------------------------------------------------------
    System name:     %s(system-name)
    System type:     %s(identity system-type)
    System config:   %s(identity system-configuration)
    "
  ("q" nil nil))
#+END_SRC




Ignore case when performing completion

#+BEGIN_SRC emacs-lisp
(setq completion-ignore-case t
      read-file-name-completion-ignore-case t)
#+END_SRC

I occasionally use =rgrep= to search through code, and it can be pretty handy to
be able to refactor the name of a method or something by making the ~*grep*~
buffer writable, that's what wgrep does.

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t
  :init (require 'wgrep))
#+END_SRC


Use a sane re-builder syntax so I don't have to have crazy escapes, see:
https://masteringemacs.org/article/re-builder-interactive-regexp-builder

#+BEGIN_SRC emacs-lisp
(setq reb-re-syntax 'string)
#+END_SRC

Set up the =site-lisp= directory so that things can be loaded from there if
applicable

#+BEGIN_SRC emacs-lisp
(when (file-exists-p "~/.emacs.d/site-lisp")
  (add-to-list 'load-path "~/.emacs.d/site-lisp"))
#+END_SRC


VLF lets me handle things like 2gb files gracefully, which is good, because
sometimes I need to look at someone's 5gb log file.

#+BEGIN_SRC emacs-lisp
(use-package vlf-setup
  :ensure vlf
  :init (require 'vlf-setup))
#+END_SRC

I don't really need bi-directional display, so let's speed up long lines

#+BEGIN_SRC emacs-lisp
(setq-default bidi-display-reordering nil)
#+END_SRC


Don't bother saving things to the kill-ring twice, remove duplicates

#+BEGIN_SRC emacs-lisp
(setq kill-do-not-save-duplicates t)
#+END_SRC


Preserve the window location when opening things

#+BEGIN_SRC emacs-lisp
(setq switch-to-buffer-preserve-window-point t)
#+END_SRC


Expand region is useful it's insane.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :defer t
  :bind (("C-c e" . er/expand-region)
         ("C-M-@" . er/contract-region)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(use-package view :ensure t
  :defer 15
  :config
  (defun View-goto-line-last (&optional line)
    "goto last line"
    (interactive "P")
    (goto-line (line-number-at-pos (point-max))))

  (define-key view-mode-map (kbd "e") 'View-scroll-half-page-forward)
  (define-key view-mode-map (kbd "u") 'View-scroll-half-page-backward)

  ;; less like
  (define-key view-mode-map (kbd "N") 'View-search-last-regexp-backward)
  (define-key view-mode-map (kbd "?") 'View-search-regexp-backward?)
  (define-key view-mode-map (kbd "g") 'View-goto-line)
  (define-key view-mode-map (kbd "G") 'View-goto-line-last)
  ;; vi/w3m like
  (define-key view-mode-map (kbd "h") 'backward-char)
  (define-key view-mode-map (kbd "j") 'next-line)
  (define-key view-mode-map (kbd "k") 'previous-line)
  (define-key view-mode-map (kbd "l") 'forward-char))

(use-package doc-view :ensure t
  :config
  (define-key doc-view-mode-map (kbd "j")
    #'doc-view-next-line-or-next-page)
  (define-key doc-view-mode-map (kbd "k")
    #'doc-view-previous-line-or-previous-page)
  ;; use 'q' to kill the buffer, not just hide it
  (define-key doc-view-mode-map (kbd "q")
    #'kill-this-buffer))

(defun eos/turn-on-viewing-mode ()
  "Turn on the viewing mode, to make looking through logs easier"
  (interactive)
  (view-mode 1)
  (when (fboundp 'eos/turn-on-hl-line)
    (eos/turn-on-hl-line)))
#+END_SRC




Undo-tree allows me to have sane undo defaults, as well as being able to
visualize it in ascii art if needed.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :init (global-undo-tree-mode t)
  :defer t
  :diminish ""
  :config
  (progn
    (define-key undo-tree-map (kbd "C-x u") 'undo-tree-visualize)
    (define-key undo-tree-map (kbd "C-/") 'undo-tree-undo)))
#+END_SRC

Usually =M-SPC= is bound to ~just-one-space~, but [[https://github.com/jcpetkovich/shrink-whitespace.el][shrink-whitespace]] is actually
a better alternative because it can shrink space between lines.

Thanks to
http://pragmaticemacs.com/emacs/delete-blank-lines-and-shrink-whitespace/ for
the link to this package.

#+BEGIN_SRC emacs-lisp
(use-package shrink-whitespace
  :ensure t
  :bind ("M-SPC" . shrink-whitespace))
#+END_SRC


Automagically resizes the windows to be the golden ratio (1.618), nice when
using a big font size and I need more eshell space

#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :ensure t
  :diminish golden-ratio-mode
  :defer t
  :init
  (add-hook 'ediff-before-setup-windows-hook (lambda () (golden-ratio-mode -1)))
  (add-hook 'ediff-quit-hook (lambda () (golden-ratio-mode 1)))
  :config
  ;; Default is 1.0, but I find this adjust just slightly less, which is nice
  (setq golden-ratio-adjust-factor .9)

  (defun eos/helm-alive-p ()
    (if (boundp 'helm-alive-p)
        (symbol-value 'helm-alive-p)))
  (defun eos/ispell-running-p ()
    (and (boundp 'ispell-choices-buffer)
         (get-buffer ispell-choices-buffer)))

  ;; Inhibit helm and ispell buffers
  (setq golden-ratio-inhibit-functions '(eos/helm-alive-p eos/ispell-running-p))

  (setq golden-ratio-exclude-buffer-regexp '("\\`\\*[Hh]elm.*\\*\\'")
        golden-ratio-exclude-buffer-names '("*Org Select*")
        golden-ratio-exclude-modes '(messages-buffer-mode
                                     fundamental-mode
                                     ediff-mode
                                     calendar-mode
                                     wget-mode
                                     calc-mode
                                     calc-trail-mode
                                     magit-popup-mode)
        golden-ratio-recenter t))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC



All restoring window placement with Emacs' built-in =winner-mode=

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'winner-mode)
#+END_SRC


Always, *always*, prefer UTF-8, anything else is insanity

#+BEGIN_SRC emacs-lisp
(set-charset-priority 'unicode)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+END_SRC

line-number-mode= displays the current line number in the mode line, however it
stops doing that in buffers when encountering at least one overly long line and
displays two question marks instead. This is pretty unhelpful, the only
workaround I've been able to find was to increase line-number-display-width to a
substantially higher value.

#+BEGIN_SRC emacs-lisp
(setq line-number-display-limit-width 10000)
#+END_SRC


When I select a region and start typing, just delete the region automatically.
This ends up working great with =expand-region=

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

Don't warn me about large files unless they're at least 30mb:

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 30 1024 1024))
#+END_SRC


If you change buffer, or focus, disable the current buffer's mark:

#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC

Don't indicate empty lines or the end of a buffer with visual
marks (the lines are cleaned up automatically anyway)

#+BEGIN_SRC emacs-lisp
(setq-default indicate-empty-lines nil)
(setq-default indicate-buffer-boundaries nil)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Ignore case when using completion for file names:

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

Confirm before killing emacs, but only on graphical sessions

#+BEGIN_SRC emacs-lisp
(when (window-system)
  (setq confirm-kill-emacs 'yes-or-no-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq line-move-visual t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq make-pointer-invisible t)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(setq-default default-tab-width 2)
(setq-default indent-tabs-mode nil)
#+END_SRC

Fix some weird color escape sequences

#+BEGIN_SRC emacs-lisp
(setq system-uses-terminfo nil)
#+END_SRC

Resolve symlinks:

#+BEGIN_SRC emacs-lisp
(setq-default find-file-visit-truename t)
#+END_SRC

Require a newline at the end of files:

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC



#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "M-%") 'query-replace-regexp)
;; This is usually bound to `C-M-l', but that locks the screen on linux, so bind
;; it to something I can use
(global-set-key (kbd "M-l") 'reposition-window)
#+end_src

Turn on auto-fill mode in text buffers:

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)

(use-package diminish :ensure t
  :init (diminish 'auto-fill-function ""))
#+END_SRC

Bury the =*scratch*= buffer, never kill it:

#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC

#+BEGIN_src emacs-lisp
;; Disabled for now
;; (desktop-save-mode 1)
;; load all values eagerly
;(setq desktop-restore-eager 10)
;; Don't save TRAMP, ftp, or "KILL" buffers
(setq desktop-files-not-to-save "\\(^/[^/:]*:\\|(ftp)$\\|KILL\\)")
;; Don't restore different frames, only restore the one frame
(setq desktop-restore-frames nil)

(use-package desktop+
  :ensure t
  :init
  (defun load-default-desktop ()
    "Load the default EOS desktop, assuming one has been saved
with the name `default'."
    (interactive)
    (desktop+-load "default")
    (message "Loaded \"default\" desktop.")))

;  (add-hook 'after-init-hook #'load-default-desktop))
#+END_SRC




Sometimes I just want words to be highlighted. I've decided to use overlays for this, and [[https://github.com/ShingoFukuyama/ov.el][ov.el]] in
particular.

#+BEGIN_SRC emacs-lisp
(use-package ov
  :ensure t
  :commands (ov-match ov-set))

#+END_SRC

* Minimalism

All of the menus can be accessed by =C-click= be it right, left, or
middle.

#+BEGIN_SRC emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
#+END_SRC


Don't beep. Just don't. Also, don't show the startup message, I
know Emacs is starting.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda ()))
(setq inhibit-startup-screen t)
#+END_SRC

* fringe-mode

I like to have the fringes of my emacs buffers to be really thin, this
can be achieved with:

#+BEGIN_SRC emacs-lisp
  (fringe-mode -1)
#+END_SRC



#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
(setq fill-column (1- (window-width)))

(setq scroll-conservatively 101
      ispell-program-name "aspell")

(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(setq-default indent-tabs-mode nil)
(global-auto-revert-mode t)
(blink-cursor-mode 0)
(winner-mode 1)
(put 'narrow-to-region 'disabled nil)
(add-hook 'text-mode-hook 'auto-fill-mode)

(setq initial-scratch-message "")

(defalias 'yes-or-no-p 'y-or-n-p) ; remplace yes no par y n


(setq custom-safe-themes t)

(setq save-interprogram-paste-before-kill t)

(save-place-mode 1)    ; save cursor position between sessions

(setq help-window-select t)                  ; focus help window when opene

(setq initial-buffer-choice "~/.hyperb/HYPB")

(defun switch-to-scratch-buffer ()
  "Switch to the `*scratch*' buffer. Create it first if needed."
  (interactive)
  (let ((exists (get-buffer "*scratch*")))
    (switch-to-buffer (get-buffer-create "*scratch*"))
    (when (and (not exists)
               (not (eq major-mode 'org-mode))
               (fboundp 'org-mode))
      (funcall 'org-mode))))

(setq ad-redefinition-action 'accept)

#+END_SRC

* Line highlighting

Line highligthing is an absolute must! 

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
#+END_SRC

** Bracket region highlighting

An extension of line highlighting is to highlight the region encased
by brackets when the cursor is at one. This is given by
=show-paren-mode= in expression mode. The negative priority is so that
the highlighting is overriden by region marking.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (setq show-paren-delay 0)
  (setq show-paren-style 'expression)
  ;;(setq show-paren-priority -50)
#+END_SRC

Now we need to set the face colour of backet region highlighting.  Use
=M-x list-faces-display= to find the colour of your =hl-line=. Do it
relative to this, but ultimately it's your taste.

#+BEGIN_SRC emacs-lisp
  (require 'paren)
  (set-face-background 'show-paren-match "#b4b4b4")
  (set-face-foreground 'show-paren-match "#000000")
  (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
#+END_SRC

* Mode line
I usually am on a laptop, I hide my status bar to avoid burn in, I
usually have emacs open. It's useful to know how much battery I have
left.

#+BEGIN_SRC emacs-lisp
  (display-battery-mode t)
#+END_SRC

* Backup settings

Aethestics is more than just theming.

The OpenVMS operating system has a nicety about it, simple version
controlling by keeping backups. I like this. Emacs can emulate this
functionality. Disk is cheap and text files are small, I'm okay with
this.

#+BEGIN_SRC emacs-lisp
  (setq version-control t        ;; OpenVMS-esque
        backup-by-copying t      ;; Copy-on-write-esque
        kept-new-versions 64     ;; Indeliable-ink-esque
        kept-old-versions 0      ;; 
        delete-old-versions nil  ;; 
        )
#+END_SRC

I don't like my folders cluttered with =*~= files, but I do like
having backups with the file. My solution is to save the files in
$(pwd)/.bak

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist   ;; Save backups in $(pwd)/.bak
        '(("." . ".bak"))        ;;
        )
#+END_SRC

Now I know if I want to roll back to a previous version of a file I
can just look for it in the .bak folder where the file is.
* Suspend-Framefg
#+BEGIN_SRC emacs-lisp
  (global-unset-key [(control z)])
  (global-unset-key [(control x)(control z)])
  (global-set-key (kbd "C-z") 'my/avy-goto-jump)

#+END_SRC
* font size and name
#+BEGIN_SRC emacs-lisp
 (set-face-attribute 'default nil :height 110)
 (add-to-list 'default-frame-alist '(font . "Deja Vu Sans Mono" ))

#+END_SRC
* find-file-hook
#+BEGIN_SRC emacs-lisp
 (defun my-find-file-check-make-large-file-read-only-hook ()
   "If a file is over a given size, make the buffer read only."
   (when (> (buffer-size) (* 1024 1024))
     (buffer-disable-undo)
     (linum-mode -1)
     (font-lock-mode -1)
     (fundamental-mode)))
#+END_SRC

* rename file and buffer
#+BEGIN_SRC emacs-lisp
 (defun rename-file-and-buffer ()
 "Rename the current buffer and file it is visiting."
 (interactive)
 (let ((filename (buffer-file-name)))
 (if (not (and filename (file-exists-p filename)))
 (message "Buffer is not visiting a file!")
 (let ((new-name (read-file-name "New name: " filename)))
 (cond
 ((vc-backend filename) (vc-rename-file filename new-name))
 (t
 (rename-file filename new-name t)
 (set-visited-file-name new-name t t)))))))


#+END_SRC

* disable, load and cycle themes
  :PROPERTIES:
  :ID:       b3dde7a0-6fe7-4c7d-83cf-13b688a4cab3
  :END:
#+BEGIN_SRC emacs-lisp
 (defun disable-all-themes ()
 "disable all active themes."
 (dolist (i custom-enabled-themes)
 (disable-theme i)))

 (defadvice load-theme (before disable-themes-first activate)
 (disable-all-themes))

 ;; Following lines to cycle through themes adapted from ivan's answer on
 ;; https://emacs.stackexchange.com/questions/24088/make-a-function-to-toggle-themes
 (setq my/themes (custom-available-themes))
 (setq my/themes-index 0)

 (defun my/cycle-theme ()
 "Cycles through my themes."
 (interactive)
 (setq my/themes-index (% (1+ my/themes-index) (length my/themes)))
 (my/load-indexed-theme))

 (defun my/load-indexed-theme ()
 (load-theme (nth my/themes-index my/themes)))
#+END_SRC

* switch to previous buffer
  :PROPERTIES:
  :ID:       22428739-1493-4277-ac45-349452a450ab
  :END:
#+BEGIN_SRC emacs-lisp
 (defun switch-to-previous-buffer ()
 (interactive)
 (switch-to-buffer (other-buffer)))
#+END_SRC

* dita
  :PROPERTIES:
  :ID:       d90a806f-2341-48e2-9727-d90fb336bf21
  :END:
#+BEGIN_SRC emacs-lisp
 (setq org-ditaa-jar-path "~/.emacs.d/ditaa0_9/ditaa0_9.jar")
#+END_SRC

* org display inline images
  :PROPERTIES:
  :ID:       e6df7cad-520e-4690-98ab-d668eeb72232
  :END:
#+BEGIN_SRC emacs-lisp
 (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)


#+END_SRC

* whitespace style
  :PROPERTIES:
  :ID:       35578a46-819d-4420-92fa-0ce3079be09f
  :END:
#+BEGIN_SRC emacs-lisp
 (setq whitespace-style '(face trailing))


#+END_SRC

* org src mode hook
#+BEGIN_SRC emacs-lisp

 (defun narrow-or-widen-dwim (p)
   "Widen if buffer is narrowed, narrow-dwim otherwise.
 Dwim means: region, org-src-block, org-subtree, or
 defun, whichever applies first. Narrowing to
 org-src-block actually calls `org-edit-src-code'.

 With prefix P, don't widen, just narrow even if buffer
 is already narrowed."
   (interactive "P")
   (declare (interactive-only))
   (cond ((and (buffer-narrowed-p) (not p)) (widen))
         ((region-active-p)
          (narrow-to-region (region-beginning)
                            (region-end)))
         ((derived-mode-p 'org-mode)
          ;; `org-edit-src-code' is not a real narrowing
          ;; command. Remove this first conditional if
          ;; you don't want it.
          (cond ((ignore-errors (org-edit-src-code) t)
                 (delete-other-windows))
		((ignore-errors (org-narrow-to-block) t))
		(t (org-narrow-to-subtree))))
         ((derived-mode-p 'latex-mode)
          (LaTeX-narrow-to-environment))
         (t (narrow-to-defun))))

(define-key org-mode-map (kbd "<S-return>") 'narrow-or-widen-dwim)

#+END_SRC

* save buffer always
#+BEGIN_SRC emacs-lisp
 (defun save-buffer-always ()
 "Save the buffer even if it is not modified."
 (interactive)
 (set-buffer-modified-p t)
 (save-buffer))
#+END_SRC

* buffers
  :PROPERTIES:
  :ID:       ce730ee0-85a1-4437-abb8-4d7daf50304d
  :END:
#+BEGIN_SRC emacs-lisp
 (defun safe-erase-buffer ()
 "Prompt before erasing the content of the file."
 (interactive)
 (if (y-or-n-p (format "Erase content of buffer %s ? " (current-buffer)))
 (erase-buffer)))

 (defun kill-other-buffers (&optional arg)
 "Kill all other buffers.
 If the universal prefix argument is used then will the windows too."
 (interactive "P")
 (when (yes-or-no-p (format "Killing all buffers except \"%s\"? "
 (buffer-name)))
 (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
 (when (equal '(4) arg) (delete-other-windows))
 (message "Buffers deleted!")))

 (defun kill-matching-buffers-rudely (regexp &optional internal-too)
 "Kill buffers whose name matches the specified REGEXP. This
 function, unlike the built-in `kill-matching-buffers` does so
 WITHOUT ASKING. The optional second argument indicates whether to
 kill internal buffers too."
 (interactive "sKill buffers matching this regular expression: \nP")
 (dolist (buffer (buffer-list))
 (let ((name (buffer-name buffer)))
 (when (and name (not (string-equal name ""))
 (or internal-too (/= (aref name 0) ?\s))
 (string-match regexp name))
 (kill-buffer buffer)))))


 (defun safe-revert-buffer ()
 "Prompt before reverting the file."
 (interactive)
 (revert-buffer nil nil))

 (defun copy-whole-buffer-to-clipboard ()
 "Copy entire buffer to clipboard"
 (interactive)
 (clipboard-kill-ring-save (point-min) (point-max)))

 (defun insert-line-above-no-indent (count)
 "Insert a new line above with no indentation."
 (interactive "p")
 (let ((p (+ (point) count)))
 (save-excursion
 (if (eq (line-number-at-pos) 1)
 (evil-move-beginning-of-line)
 (progn
 (evil-previous-line)
 (evil-move-end-of-line)))
 (while (> count 0)
 (insert "\n")
 (setq count (1- count))))
 (goto-char p)))

 (defun insert-line-below-no-indent (count)
 "Insert a new line below with no indentation."
 (interactive "p")
 (save-excursion
 (evil-move-end-of-line)
 (while (> count 0)
 (insert "\n")
 (setq count (1- count)))))

#+END_SRC

* openwith
#+BEGIN_SRC emacs-lisp
(use-package openwith 
  :ensure t
  :config

 (openwith-mode 1)
 (setq openwith-associations '(
("\\.mkv\\'" "vlc" (file)))))


#+END_SRC
