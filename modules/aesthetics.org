#+TITLE: aesthetics and sane defaults
#+AUTHOR: Alexander Soto

* Minimalism
  All of the menus can be accessed by =C-click= be it right, left, or
middle.

#+BEGIN_SRC emacs-lisp
(setq initial-buffer-choice "~/.hyperb/HYPB")

#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
#+END_SRC


Don't beep. Just don't. Also, don't show the startup message, I
know Emacs is starting.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda ()))
(setq inhibit-startup-screen t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
(setq fill-column (1- (window-width)))

(setq scroll-conservatively 101
      ispell-program-name "aspell")

(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(setq-default indent-tabs-mode nil)
(global-auto-revert-mode t)
(blink-cursor-mode 0)
(winner-mode 1)
(put 'narrow-to-region 'disabled nil)
(add-hook 'text-mode-hook 'auto-fill-mode)

(setq initial-scratch-message "")

(defalias 'yes-or-no-p 'y-or-n-p) ; remplace yes no par y n

(setq custom-safe-themes t)

(setq save-interprogram-paste-before-kill t)

(save-place-mode 1)    ; save cursor position between sessions

(setq help-window-select t)                  ; focus help window when opene

(defun switch-to-scratch-buffer ()
  "Switch to the `*scratch*' buffer. Create it first if needed."
  (interactive)
  (let ((exists (get-buffer "*scratch*")))
    (switch-to-buffer (get-buffer-create "*scratch*"))
    (when (and (not exists)
               (not (eq major-mode 'org-mode))
               (fboundp 'org-mode))
      (funcall 'org-mode))))

(setq ad-redefinition-action 'accept)

  (fringe-mode -1)

  ;show battery in modeline
  (display-battery-mode nil)

#+END_SRC

** Font size and name
 #+BEGIN_SRC emacs-lisp
 (set-face-attribute 'default nil :height 110)
 (add-to-list 'default-frame-alist '(font . "Deja Vu Sans Mono" ))

 #+END_SRC
** Line highlighting

 Line highligthing is an absolute must! 

 #+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
 #+END_SRC

*** Bracket region highlighting

 An extension of line highlighting is to highlight the region encased
 by brackets when the cursor is at one. This is given by
 =show-paren-mode= in expression mode. The negative priority is so that
 the highlighting is overriden by region marking.

 #+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (setq show-paren-delay 0)
  (setq show-paren-style 'expression)
  ;;(setq show-paren-priority -50)
 #+END_SRC

 Now we need to set the face colour of backet region highlighting.  Use
 =M-x list-faces-display= to find the colour of your =hl-line=. Do it
 relative to this, but ultimately it's your taste.

 #+BEGIN_SRC emacs-lisp
  (require 'paren)
  (set-face-background 'show-paren-match "#b4b4b4")
  (set-face-foreground 'show-paren-match "#000000")
  (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
 #+END_SRC

** Suspend-Frame
 #+BEGIN_SRC emacs-lisp
  (global-unset-key [(control z)])
  (global-unset-key [(control x)(control z)])
  (global-set-key (kbd "C-z") 'my/avy-goto-jump)

 #+END_SRC
** Find-file-hook
 #+BEGIN_SRC emacs-lisp
 (defun my-find-file-check-make-large-file-read-only-hook ()
   "If a file is over a given size, make the buffer read only."
   (when (> (buffer-size) (* 1024 1024))
     (buffer-disable-undo)
     (linum-mode -1)
     (font-lock-mode -1)
     (fundamental-mode)))
 #+END_SRC

** Rename file and buffer
 #+BEGIN_SRC emacs-lisp
 (defun rename-file-and-buffer ()
 "Rename the current buffer and file it is visiting."
 (interactive)
 (let ((filename (buffer-file-name)))
 (if (not (and filename (file-exists-p filename)))
 (message "Buffer is not visiting a file!")
 (let ((new-name (read-file-name "New name: " filename)))
 (cond
 ((vc-backend filename) (vc-rename-file filename new-name))
 (t
 (rename-file filename new-name t)
 (set-visited-file-name new-name t t)))))))


 #+END_SRC

** Switch to previous buffer
   :PROPERTIES:
   :ID:       22428739-1493-4277-ac45-349452a450ab
   :END:
 #+BEGIN_SRC emacs-lisp
 (defun switch-to-previous-buffer ()
 (interactive)
 (switch-to-buffer (other-buffer)))
 #+END_SRC

** Org display inline images
   :PROPERTIES:
   :ID:       e6df7cad-520e-4690-98ab-d668eeb72232
   :END:
 #+BEGIN_SRC emacs-lisp
 (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)


 #+END_SRC

** whitespace style
   :PROPERTIES:
   :ID:       35578a46-819d-4420-92fa-0ce3079be09f
   :END:
 #+BEGIN_SRC emacs-lisp
 (setq whitespace-style '(face trailing))
 #+END_SRC

** Disable, load and cycle themes
   :PROPERTIES:
   :ID:       b3dde7a0-6fe7-4c7d-83cf-13b688a4cab3
   :END:
 #+BEGIN_SRC emacs-lisp
 (defun disable-all-themes ()
 "disable all active themes."
 (dolist (i custom-enabled-themes)
 (disable-theme i)))

 (defadvice load-theme (before disable-themes-first activate)
 (disable-all-themes))

 ;; Following lines to cycle through themes adapted from ivan's answer on
 ;; https://emacs.stackexchange.com/questions/24088/make-a-function-to-toggle-themes
 (setq my/themes (custom-available-themes))
 (setq my/themes-index 0)

 (defun my/cycle-theme ()
 "Cycles through my themes."
 (interactive)
 (setq my/themes-index (% (1+ my/themes-index) (length my/themes)))
 (my/load-indexed-theme))

 (defun my/load-indexed-theme ()
 (load-theme (nth my/themes-index my/themes)))
 #+END_SRC

* Buffers
  :PROPERTIES:
  :ID:       ce730ee0-85a1-4437-abb8-4d7daf50304d
  :END:
#+BEGIN_SRC emacs-lisp
 (defun safe-erase-buffer ()
 "Prompt before erasing the content of the file."
 (interactive)
 (if (y-or-n-p (format "Erase content of buffer %s ? " (current-buffer)))
 (erase-buffer)))

 (defun kill-other-buffers (&optional arg)
 "Kill all other buffers.
 If the universal prefix argument is used then will the windows too."
 (interactive "P")
 (when (yes-or-no-p (format "Killing all buffers except \"%s\"? "
 (buffer-name)))
 (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
 (when (equal '(4) arg) (delete-other-windows))
 (message "Buffers deleted!")))

 (defun kill-matching-buffers-rudely (regexp &optional internal-too)
 "Kill buffers whose name matches the specified REGEXP. This
 function, unlike the built-in `kill-matching-buffers` does so
 WITHOUT ASKING. The optional second argument indicates whether to
 kill internal buffers too."
 (interactive "sKill buffers matching this regular expression: \nP")
 (dolist (buffer (buffer-list))
 (let ((name (buffer-name buffer)))
 (when (and name (not (string-equal name ""))
 (or internal-too (/= (aref name 0) ?\s))
 (string-match regexp name))
 (kill-buffer buffer)))))


 (defun safe-revert-buffer ()
 "Prompt before reverting the file."
 (interactive)
 (revert-buffer nil nil))

 (defun copy-whole-buffer-to-clipboard ()
 "Copy entire buffer to clipboard"
 (interactive)
 (clipboard-kill-ring-save (point-min) (point-max)))

 (defun insert-line-above-no-indent (count)
 "Insert a new line above with no indentation."
 (interactive "p")
 (let ((p (+ (point) count)))
 (save-excursion
 (if (eq (line-number-at-pos) 1)
 (evil-move-beginning-of-line)
 (progn
 (evil-previous-line)
 (evil-move-end-of-line)))
 (while (> count 0)
 (insert "\n")
 (setq count (1- count))))
 (goto-char p)))

 (defun insert-line-below-no-indent (count)
 "Insert a new line below with no indentation."
 (interactive "p")
 (save-excursion
 (evil-move-end-of-line)
 (while (> count 0)
 (insert "\n")
 (setq count (1- count)))))

#+END_SRC

* Backup settings

Aethestics is more than just theming.

The OpenVMS operating system has a nicety about it, simple version
controlling by keeping backups. I like this. Emacs can emulate this
functionality. Disk is cheap and text files are small, I'm okay with
this.

#+BEGIN_SRC emacs-lisp
  (setq version-control t        ;; OpenVMS-esque
        backup-by-copying t      ;; Copy-on-write-esque
        kept-new-versions 64     ;; Indeliable-ink-esque
        kept-old-versions 0      ;; 
        delete-old-versions nil  ;; 
        )
#+END_SRC

I don't like my folders cluttered with =*~= files, but I do like
having backups with the file. My solution is to save the files in
$(pwd)/.bak

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist   ;; Save backups in $(pwd)/.bak
        '(("." . ".bak"))        ;;
        )
#+END_SRC

Now I know if I want to roll back to a previous version of a file I
can just look for it in the .bak folder where the file is.
* Create window snapshots
#+BEGIN_SRC emacs-lisp
  (defvar window-snapshots '())

  (defun save-window-snapshot ()
    "Save the current window configuration into `window-snapshots` alist."
    (interactive)
    (let ((key (read-string "Enter a name for the snapshot: ")))
      (setf (alist-get key window-snapshots) (current-window-configuration))
      (message "%s window snapshot saved!" key)))

  (defun get-window-snapshot (key)
    "Given a KEY return the saved value in `window-snapshots` alist."
    (let ((value (assoc key window-snapshots)))
      (cdr value)))

  (defun restore-window-snapshot ()
    "Restore a window snapshot from the window-snapshots alist."
    (interactive)
    (let* ((snapshot-name (completing-read "Choose snapshot: " (mapcar #'car window-snapshots)))
           (snapshot (get-window-snapshot snapshot-name)))
      (if snapshot
          (set-window-configuration snapshot)
        (message "Snapshot %s not found" snapshot-name))))


#+END_SRC

* Ditaa
  :PROPERTIES:
  :ID:       d90a806f-2341-48e2-9727-d90fb336bf21
  :END:
#+BEGIN_SRC emacs-lisp
 (setq org-ditaa-jar-path "~/.emacs.d/ditaa0_9/ditaa0_9.jar")
#+END_SRC

* Narrow or widen on org-heading
#+BEGIN_SRC emacs-lisp
 (defun narrow-or-widen-dwim (p)
   "Widen if buffer is narrowed, narrow-dwim otherwise.
 Dwim means: region, org-src-block, org-subtree, or
 defun, whichever applies first. Narrowing to
 org-src-block actually calls `org-edit-src-code'.

 With prefix P, don't widen, just narrow even if buffer
 is already narrowed."
   (interactive "P")
   (declare (interactive-only))
   (cond ((and (buffer-narrowed-p) (not p)) (widen))
         ((region-active-p)
          (narrow-to-region (region-beginning)
                            (region-end)))
         ((derived-mode-p 'org-mode)
          ;; `org-edit-src-code' is not a real narrowing
          ;; command. Remove this first conditional if
          ;; you don't want it.
          (cond ((ignore-errors (org-edit-src-code) t)
                 (delete-other-windows))
		((ignore-errors (org-narrow-to-block) t))
		(t (org-narrow-to-subtree))))
         ((derived-mode-p 'latex-mode)
          (LaTeX-narrow-to-environment))
         (t (narrow-to-defun))))

(define-key org-mode-map (kbd "<S-return>") 'narrow-or-widen-dwim)

#+END_SRC

* Save buffer always
#+BEGIN_SRC emacs-lisp
 (defun save-buffer-always ()
 "Save the buffer even if it is not modified."
 (interactive)
 (set-buffer-modified-p t)
 (save-buffer))
#+END_SRC

* Options
#+BEGIN_SRC emacs-lisp
;Ignore case when performing completion
(setq completion-ignore-case t
      read-file-name-completion-ignore-case t)

;Set up the =site-lisp= directory so that things can be loaded from there if applicable
(when (file-exists-p "~/.emacs.d/site-lisp")
  (add-to-list 'load-path "~/.emacs.d/site-lisp"))


;I don't really need bi-directional display, so let's speed up long lines
(setq-default bidi-display-reordering nil)

; Don't bother saving things to the kill-ring twice, remove duplicates
(setq kill-do-not-save-duplicates t)

;Preserve the window location when opening things
(setq switch-to-buffer-preserve-window-point t)
(setq x-select-enable-clipboard t)

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

(add-hook 'after-init-hook #'winner-mode)

;Always, *always*, prefer UTF-8, anything else is insanity
(set-charset-priority 'unicode)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))


(setq line-number-display-limit-width 10000)

;When I select a region and start typing, just delete the region automatically.
(delete-selection-mode 1)


;Don't warn me about large files unless they're at least 100mb:
(setq large-file-warning-threshold (* 100 1024 1024))

;If you change buffer, or focus, disable the current buffer's mark:
(transient-mark-mode 1)

;Don't indicate empty lines or the end of a buffer with visual marks
(setq-default indicate-empty-lines nil)
(setq-default indicate-buffer-boundaries nil)

(line-number-mode 1)
(column-number-mode 1)


;Ignore case when using completion for file names:
(setq read-file-name-completion-ignore-case t)

;Confirm before killing emacs, but only on graphical sessions

(when (window-system)
  (setq confirm-kill-emacs 'yes-or-no-p))

(setq line-move-visual t)

(setq make-pointer-invisible t)

(setq-default fill-column 80)
(setq-default default-tab-width 2)
(setq-default indent-tabs-mode nil)

;Fix some weird color escape sequences

(setq system-uses-terminfo nil)

(setq-default find-file-visit-truename t)

(setq require-final-newline t)


(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "M-%") 'query-replace-regexp)
;; This is usually bound to `C-M-l', but that locks the screen on linux, so bind
;; it to something I can use
(global-set-key (kbd "M-l") 'reposition-window)



(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))


#+end_src
